# race condition & Thread safe

1. **멀티 스레드/프로세스 환경에서 여러 실행 흐름이 하나의 작업을 처리하는 경우 race condition이 발생할 수 있는데 이들은 왜 일어나는 것이고 이를 해결하기 위한 기법과 장단점에 대해서 설명하시오. (3개 이상 해결 방법 서술)**
2. **Java 에서 여러 스레드를 사용해 하나의 연산을 처리하려고 할 때 Thread Safe 하게 연산을 수행할 수 있도록 하는 방법에 대해서 3가지 이상 조사하시오.**



#### race condition

두 개 이상의 프로세스가 공통 자원을 병행적으로 읽거나 쓰는 동작을 할 때, 공용 데이터에 대한 접근이 어떤 순서에 따라 이루어졌는지에 따라 그 실행 결과가 같지 않고 달라지는 상황을 말한다.

 Race의 뜻 그대로, 간단히 말하면 경쟁하는 상태, 즉 두 개의 스레드가 하나의 자원을 놓고 서로 사용하려고 경쟁하는 상황을 말한다. 

경쟁 프로세스의 경우, 세 가지 제어 문제에 직면한다. Mutual exclusion, deadlock, starvation



#### mutual exclusive

Race condition을 막기 위해서는 두 개 이상의 프로세스가 공용 데이터에 동시에 접근을 하는 것을 막아야 한다. 

즉, 한 프로세스가 공용 데이터를 사용하고 있으면 그 자원을 사용하지 못하도록 막거나, 다른 프로세스가 자원을 사용하지 못하도록 막으면 이 문제를 피할 수 있다. 이것을 상호 배제라고 부른다.



#### Deadlock

그러나 상호 배제를 시행하면 추가적인 제어 문제가 발생한다. 하나는 교착상태 즉 여기서 말하는 Deadlock이다. 프로세스가 각자 프로그램을 실행하기 위해 두 자원 모두에 엑세스 해야 한다고 가정할 때 프로세스는 두 자원 모두를 필요로 하므로 필요한 두 리소스를 사용하여 프로그램을 수행할 때까지 이미 소유한 리소스를 해제하지 않는다. 이러한 상황에서 두 프로세스는 교착 상태에 빠지게 되는 문제가 발생할 수 있다.



#### Starvation

이 제어 문제는 ‘기아 상태’라고 한다. 이러한 문제는 프로세스들이 더 이상 진행을 하지 못하고 영구적으로 블록되어 있는 상태로, 시스템 자원에 대한 경쟁 도중에 발생할 수 있고 프로세스 간의 통신 과정에도 발생할 수 있는 문제이다. 두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에 결과적으로는 아무것도 완료되지 못하는 상태가 되게 된다.

 

-> 이렇게 race condition 인 경우에는 스레드의 실행 순서를 잘 조절해주지 않으면 이상한 상태, 비정상적인 상태가 나오게 된다. 이 문제는 항상 발생하는 것이 아니라 특정한 순서대로 수행되었을 때 발생하는 것이다. 이 문제는 디버깅을 할 때에는 전혀 보이지 않는 문제점이고, 발생 시에 모든 프로세스에 원하는 결과가 발생하는 것을 보장할 수 없으므로 후에 더욱 큰 문제를 야기할 수 있으므로 반드시 피해야 하는 상황이다.

이러한 문제가 발생하지 않도록, OS는 다른 프로세스의 의도하지 않은 간섭으로부터 각 프로세스의 데이터 및 물리적 자원을 보호해야 하며 여기에 메모리, 파일 및 I/O 장치와 관련된 내용이 포함된다.

그리고 프로세스에서 수행하는 내용과 프로세스가 생성하는 결과는, 다른 동시 프로세스의 실행 속도와 무관, 즉 기능과 결과는 서로 독립적이어야 한다.



### race condition in software

race condition은 컴퓨터 프로그램이 프로그램의 프로세스 또는 스레드의 순서와 타이밍에 의존적일 때 발생한다.

Critical race condition은 프로세스 또는 스레드가 shared state에 의존적일 때 발생한다.

shared state 들에 의한 연산들은 critical section에서 상호 배제로 처리되어야 한다. 상호 배제의 규칙을 어길시 shared state를 방해한다.

data race는 race condition의 한 종류다.

data race는 다양한 formal 메모리 모델의 중요한 부분들이다.

memory model 은 c11 과 c+11 기준에서 정의되었고 data race를 포함하는 c, c++ 프로그램은 undefiend behavior를 가졌다.

race condiion은 재생산하고 디버그하는것이 어렵다 . 왜냐하면 결과는 비결정적이고 간접하는 스레드 사이에서 타이밍이 의존적이다.

이러한 문제들은 디버그 모드 작동 시, extra 로깅이 추가시, 디버거가 추가될 때 사라질 수 있다.

디버깅동안 사라지는 버그들은 "Heisenbug"로 불린다.

heisenbug는 안전한 소프트웨어 디자인에 의해 race conditions를 피하는것이 더 좋다.



**상호 배제시 어기고 데이터가 의존적일 때 예시**

thread1, thread2는 전역 변수를 1씩 증가시키는 연산을 한다.

![image-20210829163815566](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210829163815566.png)

위 표의 마지막 결과는 2이다. 

그러나 두 스레드는 로킹이나 동기화 없이 동시에 스레드가 작동했고 연산의 결과는 잘못 되었다.



![image-20210829163953834](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210829163953834.png)

위 표의 마지막 결과는 1이다. 

왜냐하면 증가 연산은 상호 배제적이지 않기 때문이다.

상호 배제 연산들은 메모리 위치 같은 자원이 동작하는 동안 간섭받을 수 없다.



### data race

모든 data race를 race condition의 하위집합으로 간주하지는 않는다.

data race의 정확한 정의는 사용중인 동시성 모델에 한정되지만 전형적으로 위험한 상황에서 다른 스레드의 메모리 작업이 해당 메모리 작업이 잠재적으로 메모리 위치 접근을 시도할 수 있는 상황을 말한다.

이는 data race가 없는 프로그램에서도 타이밍으로 인해 비결정성을 가질 수 있기 때문에 데이터 레이스가 race condition과 다르다는 것을 의미한다.

여러 플랫폼에서 두 스레드가 동시에 메모리 위치에 쓸 경우 메모리 위치가 각 스레드가 쓰려고 하는 값을 나타내는 비트의 임의적이고 의미 없는 조합인 값을 보유하게 될 수 있기 때문에 위험할 수 있다. 이로 인해 결과 값이 쓰기를 시도하지 않은 값일 경우 메모리가 손상될 수 있다.

마찬가지로, 다른 스레드가 쓰는 동안 한 스레드가 위치에서 읽는 경우, 메모리 위치가 쓰기 전에 보유하고 있는 값을 나타내는 비트와 쓰기 중인 값을 나타내는 비트의 임의적이고 의미 없는 조합인 값을 읽기가 반환할 수 있다.

많은 플랫폼에서는 동시 엑세스를 위해 특별한 메모리 작업이 제공된다. 이 경우 일반적으로 이러한 특수 작업을 사용한 동시 액세스는 안전하지만 다른 메모리 작업을 사용한 동시 엑세스는 위험하다.

때로는 그러한 특수작전(동시 접근에 안전한)을 원자작전 또는 동기화작전이라고 하는 반면, 일반작전(동시 접근에 안전하지 않은)을 데이터작전이라고 한다. 이것이 아마도 용어가 데이터 경주인 이유일 것입니다. 동기화 작업만 포함하는 인종 조건이 있는 많은 플랫폼에서 그러한 인종은 비 결정적이지만 그렇지 않으면 안전할 수 있습니다. 그러나 데이터 경주는 메모리 부패 또는 정의되지 않은 행동으로 이어질 수 있습니다.



### race condition vs data race

- **race condition**

  이벤트의 타이밍이나 순서가 프로그램의 정확성에 영향을 미칠 때 발생하는 결함

  race condition을 만들기 위해서는 external timing 이나 ordering non-determinism이 필요하다. (컨텍스트 스위치, OS 신호, 멀티 프로세서에서 메모리 작업, 하드웨어 인터럽트 )

- **data race**

  프로그램에서 두개의 메모리 접근이 있을 때 발생

  - 같은 메모리 위치를 가르키는 경우
  - 두 스레드에 의해 동시적으로 수행되는 경우
  - 데이터를 읽지 않은 경우
  - 동기화 작업이 아닌 경우



### OS 에서 Race Condition이 일어나는 경우

user mode 일 때 보다 커널 모드 일 때 race condition이 많이 일어난다.

-> 커널 모드에서는 , 커널에 있는 자원을 여러 프로세스가 공유할 수 있기 때문



#### 1. 프로세스의 시스템 호출로 인해 , 커널 모드로 수행중인데 context switch가 일어나는 경우

![image-20210829191025100](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210829191025100.png)

프로세스 A가 커널 모드로 작업을 수행하면서, count 값을 읽어온 후 증가시키려고 하는 와중에 context switch가 발생했다.

프로세스 B에서도 count 변수의 값을 변경하게 된다.

이 때, 프로세스 B에 의해 변경된 count 값은 반영되지 않는다. 왜냐하면 커널에서는 프로세스 B로  인해 count 값이 변경되기 이전의 count 값을 가져온 상태기 때문이다.



#### 해결 방안

커널 모드에서 수행 중일 때는 cpu를 뺏지 않게 한다. -> 커널 모드에서 유저 모드로 바뀔 때 cpu를 빼앗는다.





#### 2. 커널 모드로 작업 중에, 인터럽트가 발생한 경우

![image-20210829193448215](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210829193448215.png)

#### 해결 방안

커널에서 공유 변수에 접근하고 있을 때에는, 인터럽트를 받지 아니함



#### 3. 멀티 프로세서에서, 커널에 있는 shared memory에 접근할 때



#### 해결 방안

한번에 하나의 cpu만이 커널에 접근할 수 있도록 함

커널 내부에 있는 공유 데이터에 접근할 때마다 lock / unlock을 하는 방법



### 예방할 수 있는 방법

#### 세마포어

![image-20210829220840997](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210829220840997.png)

공유된 자원의 데이터를 여러 프로세스가 접근하는 것을 막는 것이다. 또한 세마포어는 리소스의 상태를 나타내는 간단한 카운터라고 할 수 있는데, 일반적으로 비교적 긴 시간을 확보하는 리소스에 대해 이용하게 되며, 운영체제의 리소스를 경쟁적으로 사용하는 다중 프로세스에서 행동을 조정하거나 동기화 시키는 기술이다. 다시 말해서 하나의 스레드만 들어가게 할 수도 있고 여러 개의 스레드가 들어가게 할 수 있다. 이것이 뮤텍스와의 차이이다.



#### Mutex

![image-20210829220929119](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210829220929119.png)

공유된 자원의 데이터를 여러 스레드가 접근하는 것을 막는 방법이다. 즉, Critical Section을 가진 쓰레드들의 Running time이 서로 겹치지 않게 각각 단독으로 실행되게 하는 기술이다. 다중 프로세스들이 공유 리소스에 대한 접근을 조율하기 위해 locking과 unloking을 사용하는데, 다시 말해서 상호배제를 함으로써 두 쓰레드가 동시에 사용할 수 없다는 뜻이다.



#### 모니터

<img src="C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210905222616590.png" alt="image-20210905222616590" style="zoom:67%;" />

- 2개의 큐가 있다: 배타동기(`Mutual exclusion queue`) + 조건동기(`Conditional synchronization`)
- 공유자원 접근함수에는 최대 1개의 쓰레드만 집입가능: 나머지는 큐에서 진입못하고 기다리고 있어야한다.
- 진입 쓰레드가 조건 동기로 블록되면 새 스레드 진입가능: `wait call`> 들어왔던 스레드는 Conditions synchronization에 갇히게 된다. 그러면 새 쓰레드가 진입가능하다.
- 새 쓰레드는 조건동기로 블록된 스레드를 깨울 수 있음: `notify()`> 블록된 스레드를 깨워준다.
- 깨워진 스레드는 현재 스레드가 나가면 재진입할 수 있음: 하나의 스레드만 있을 수 있으니까, 그 비어진 자리에 깨워진 스레드가 들어올 수 있게 된다.





### Thread-safe 란

멀티 스레드 프로그래밍에서 여러 Thread로 부터 어떤 method나 variable, object에 동시에 접근이 이뤄져도 프로그램의 실행에 문제가 없다.

하나의 function이 한 스레드 로부터 호출되어 실행 중일 때 다른 스레드가 동일한 함수를 호출하여 동시에 실행되더라도 각 스레드에서 함수의 수행 결과가 바르게 나오는 것



#### ConcurrentHashMap

 검색과 갱신 전체에 걸쳐 Thread-Safe 함을 보장하면서도 높은 성능을 보장하는 HashMap 이다. HashMap처럼 기본적으로는 Hashtable 과 동일한 Spec을 제공한다.  Hashtable 또한 Thread-Safe를 보장한다. 그러나 차이점은 모든 작업이 Thread-Safe 임에도 불구하고 검색작업(get과 같은)에는 Lock이 수반되지 않으며, 전체 테이블을 잠궈야 하는 액션도 없다. 



#### StringBuilder vs StringBuffer

StringBuffer와 StringBuilder 클래스는 String과 다르게 mutable 하다.

즉, 문자열 연산을 할 때 클래스는 한 번만 만들고(new), 메모리의 값을 변경시켜서 문자열을 변경한다. (문자열 연산이 많을 때 사용하면 좋다)

그렇다면 StringBuffer와 StringBuilder의 차이는 무엇인가?

StringBuffer는 멀티 스레드 환경에서 synchronized 키워드가 가능하므로 동기화가 가능하다. 즉, threaed-safe 하다.

StringBuilder는 thread-safe 하지 않다.

StringBuilder는 동기화를 지원하지 않기 때문에 멀티 쓰레드 환경에서는 적합하지 않다. 

대신 StringBuilder가 동기화를 고려하지 않기 때문에 싱글스레드 환경에서 StringBuffer에 비해 연산처리가 빠른 장점이 있다. -> 이게 알고리즘 문제 풀때 StringBuilder를 사용하라고 권장하는 이유인 것 같다.



### AtomicInteger

AtomicInteger는 int 자료형을 갖고 있는 wrapping 클래스다.

AtomicInteger 클래스는 멀티스레드 환경에서 동시성을 보장한다.

자바에서 동시성 문제를 해결하는데 3가지 방법이 있다.

- volatile은 스레드 1에서 쓰고, 스레드 2에서 읽는 경우만 동시성을 보장한다. 두개의 스레드에서 쓴다면 문제가 될 수 있다.
- synchronized를 쓰면 안전하게 동시성을 보장할 수 있다. 하지만 비용은 크다.
- Atomic 클래스는 compare and swap을 이용하여 동시성을 보장한다. 여러 스레드에서 데이터를 write해도 문제가 없다.



#### volatile

이 키워드를 적용한 변수는 L1, L2등에 캐시를 참고하지 않고 직접 메모리를 참조하도록 한다.

캐시 때문에 동기화가 이뤄지지 않는 문제는 얼추 해결되는 듯 보이나 완전히 동기화 문제가 해결되는 것은 아니다.

메모리를 직접 참고하더라도 스레드 간의 접근에 의한 동기화 문제는 남아있기 ㄸ문이다.

이럴 때 락을 이용한 동기화 처리를 해줘야 하는데 synchronized 키워드가 여기서 사용된다.

