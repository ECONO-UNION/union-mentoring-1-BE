### 1. Synchronization과 Asynchronization 은 무엇인가?

우리는 영상 컨텐츠를 접할 때 자막 싱크나 음성 싱크가 안맞는다고 하는 경우를 종종 볼 수 있다. 

여기서 '싱크'는 무엇일까?

여기서 말하는 싱크란 영어로 Sync 즉, Synchronization의 약자이다.

synchronization이란 sync(함께)와 chrono(시간)의 합성어로 **함께 시간을 맞춘다**라는 뜻으로 해석된다. 또한 Sync를 적용하기 위해선 두 대상이 필요하다는 것을 추측할 수 있다.

고로 영상 컨텐츠에서 자막 싱크나 음성 싱크가 안맞는다는 것은 영상과 자막 또는 음성이 서로 시간을 맞추지 않고 진행된다는 것을 의미한다!! 

싱크가 맞는다면 영상의 특정 부분이 상영될 때 이와 시간을 맞춘 자막 또는 음성을 의미하겠죠?

**즉, Synchronization 이란 두 대상간에 서로 시간을 맞추는 것이고, Asynchronization 이란 Synchronization에 부정의 접두사 a를 붙여 두 대상간에 서로 시간을 맞추지 않는 것을 의미한다.**

요즘 Synchronization의 개념은 두 대상이 시간을 맞추는 것 이상으로서의 역할을 하고 있는 듯 하기도 하다. 대표적으로는 Data Synchronization 과 같이...?

> ### Data Synchronization
>
> Data Synchronization은 source에서 target 데이터 저장소로 또는 그 반대로 데이터들의 일관성을 만드는 작업을 의미한다. 이는 파일 동기화 및 모바일 장치 동기화를 비롯한 다양한 어플리케이션의 기본입니다. 
>
> Data Consistency : 데이터 일관성이란 다른 위치에 보관된 동일한 데이터가 일치하는지 여부를 나타냅니다.



### 2. Blocking과 Non-Blocking 은 무엇인가?

Blocking이란 막는다는 뜻을 가지고 있다. 

그렇다면 "누가 무엇을 막는 것인가?"에 대해서 생각해 보면 "작업을 처리하는 대상(ex. Thread, Process)이 제어권의 이동을 막는다."라고 할 수 있다. 

그렇다면 "어떤 경우에 작업을 처리하는 대상이 제어권의 이동을 막는가?" 에 대해서 생각해 보면 '작업을 처리하는 대상이 할당받은 작업을 수행하는 동안 제어권이 다른 대상에게 이동하는 것을 막는다' 라고 생각할 수 있다.

**즉, Blocking이란 작업을 처리하는 대상이 작업을 수행하는 동안에 제어권이 다른 대상에게 이동하는 것을 막는 처리 방법이고 Non-Blocking이란 작업이 수행중이더라도 제어권이 다른 대상으로 이동하게 만드는 것을 의미한다.**

대표적인 예로 카페 카운터 점원과 바리스타를 들 수 있다. 

카운터 점원이 손님으로부터 주문을 받아 바리스타에게 주문서를 넘겨주고 커피 서빙을 위해 커피가 나올 때까지 기다린다면 이 과정동안 카운터 점원은 한 손님의 요청밖에 처리하지 못한다. 무엇보다 더 심각한 것은 바리스타의 수를 100명, 1000명으로 넘겨도 카운터 점원이 병목이 되어 요청 속도는 더이상 빨라지지 않는다는 점이다. 이 것이 대표적인 Blocking의 예제이다.

카운터 점원은 손님으로부터 주문을 받아 바리스타에게 주문서를 넘겨주고 바리스타로부터 커피가 나올 때까지 기다리지 않고 계속 다음 손님의 주문을 받고 커피가 나온 경우에만 해당 손님에게 서빙하는 경우가 있다. 이 경우 바리스타의 수가 늘어난 만큼 손님에게 커피를 서빙하는 속도가 빨라진다는 점이 좋다. 이것이 대표적인 Non-Blocking의 예제이다. 

이러한 Blocking 작업으로부터 발생하는 병목을 없애기 위해 Non-Blocking을 지원하고자 개발자들은 Threading, Callbacks, Future, Promise, Reactive, Coroutines, .... 등의 다양한 솔루션들을 개발했다.



### 2. Tasks 를 수행하기위해 다음의 방법을 사용할 수 있을텐데 각각의 예시를 들어보라.

**Synchronous Blocking**

<img src="/Users/user/Library/Application Support/typora-user-images/image-20210814172925497.png" alt="image-20210814172925497" style="zoom:25%;" />

Task A, B, C 가 서로 시간을 잘 맞추면서 작업이 완료되기전에 제어권 뺏지 않고 순차적으로 잘 수행되고 있다.



**Synchronous Non-Blocking**

<img src="/Users/user/Library/Application Support/typora-user-images/image-20210814173151509.png" alt="image-20210814173151509" style="zoom:25%;" />

Task A와 B가 시간을 잘 맞추면서 수행되고 있지만 작업이 완료되기 전에 제어권을 뺏어서 각자의 작업을 수행한다.



**Asynchronous Blocking**

<img src="/Users/user/Library/Application Support/typora-user-images/image-20210814174800194.png" alt="image-20210814174800194" style="zoom:25%;" />

Task A, B, C가 수행되는 동안 서로의 제어권을 가져오지 않았지만 서로 시간을 맞추지 않고 작업이 수행되어지는 경우



**Asynchronous Non-Blocking** (코어가 2개라고 가정)



<img src="/Users/user/Library/Application Support/typora-user-images/image-20210814175832957.png" alt="image-20210814175832957" style="zoom:25%;" />

Thread A의 Task A, C만 보면 Synchronous Non-blocking 으로 볼 수 있지만, (Task A, C)와 Thread B의 Task B로 보면 서로 시간도 맞추고 있지 않고 A와 C가 수행되는 중에 제어권도 B에게 할당이 되므로(코어가 2개) Asynchronous Non-Blocking이다.



### 3. MultiThread 환경에서 Blocking과 Non-Blocking 을 활용해 Tasks를 각각 처리한다면 어떤 것이 더 빠르겠는가?

MultiThreading은 Blocking 작업을 Non-Blocking 으로 바꿀 수 있는 처리 방식이다. 

왠만한 경우 Multithread 환경에서 Blocking 작업을 수행하는 것 보단 Non-Blocking 작업을 수행하는 것이 더 빠르겠지만 작업을 수행함에 있어서 이전의 결과가 필요한 경우 즉, Pipeline 작업의 경우 Blocking 작업이 Context Switch 전환 비용이 없기 때문에 더 빠를 수 있지만 비슷하리라 생각한다.

Blocking 작업을 Non-Blocking으로 수행하는 방법 중 하나는 병렬 흐름을 만드는 것인데 당연히 MultiProcessing으로도 가능하다. 하지만 공유 자원 측면에서 Code, Data, Heap 영역을 공유하는 Multithreading의 연산 속도가 더 빠르기 때문에 이러한 문제를 냈었다.

병렬흐름을 만들지 않고도 Blocking 작업을 Non-Blocking으로 변환시킬 수 있는데 대표적인 방법에는 Callback, Coroutine, Promise 등이 존재한다.



### 4. 정리

**동기/비동기 : 여러 대상이 서로 시간을 맞추는지의 여부**
\------------------------------------------------------------------------------------------
**블로킹/논블로킹 : 하나의 작업이 수행이 완료될 때까지 다른 작업들이 제어권을 가지지 않고 기다리는지 여부.**
=> 멀티 스레드를 활용하면 하나의 스레드에서 수행되고 있는 작업이 완료되지 않고 I/O를 기다리더라도 다른 스레드를 활용해서 다른 작업들을 병렬적으로 처리할 수 있다.

즉, Multithread를 쓰면 Blocking 작업은 I/O를 기다리지 않고 다른 스레드로 다른 작업을 처리할 수 있는거죠...(우리는 두 개의 실행 흐름(thread)으로 작업을 표현했지만, 작업의 입장에서만 보면 Blocking이 non-blocking으로 바뀌는 거죠)

=====================================================================
특정 작업이 수행될 때 다른 작업의 수행 여부가 Blocking과 Non-Blocking을 판단하는 기준이라고 생각하면 될 것 같아요...!! ㅎㅎ

서든어택은 맵 로딩 작업 수행하면서 에너지바도 계속 표현하니까 Non-Blocking 인거구요

데이터베이스는 데이터의 무결성을 위해서 연산(CRUD 등) 작업 수행간에 다른 작업은 수행하지 않으니까 Blocking 인거구요... ㅎㅎ

---

## 5. 다시 정리 

### Synchronous vs Asynchronous

- Synchronous란 두개의 대상이 서로 시간을 맞추어 행동하는 것이다.
- Asynchronous란 두개의 대상이 서로 시간을 맞추지 않는 것이다.
- 여기서 말하는 대상이란 함수, 모듈, 어플리케이션 등이 될 수 있다. 즉 이러한 두 대상이 서로 시간을 맞추어 행동하는지의 여부를 의미하는 것이다.
  (카페 알바와 바리스타가 손님의 요청을 서비스하는데 서로 시간을 맞추어 행동하는지의 여부로도 생각할 수 있다.)



### Blocking vs Non-Blocking

- Blocking이란 특정 작업을 수행하는 대상이 할당된 작업을 완료할 때까지 다른 작업을 수행하지 않는 것이다.

- Non-Blocking이란 특정 작업을 수행하는 대상이 할당된 작업을 완료하지 않아도 다른 작업을 수행할 수 있게 하는 것이다.

- 여기서 말하는 대상이란 스레드, 프로세스 등 특정 Task를 수행하는 대상을 의미한다. 
  즉 이러한 대상이 할당된 작업을 완료할 때까지 중간에 다른 작업을 수행하느냐의 여부를 의미하는 것이다.

  (카페 도메인에서 알바가 손님의 요청을 받고난 뒤 바리스타로부터 음료가 나오기를 기다려서 손님에게 서빙할 건지 아니면 손님에게 요청을 받고난 뒤 자신의 할일을 하거나 다른 손님의 요청을 받으면서 음료가 나오면 이를 손님에게 서빙할 건지로써 Blocking과 Non-Blocking을 구분할 수 있다.)



### 각 Case 별 스터디를 위한 상황 가정

1. 카페에는 알바 2명과 바리스타 4명이 존재한다. 
2. 우리는 갑자기 방문한 100명의 손님에게 서비스하기 위해서 아래와 같은 방법을 사용한다.
3. 손님에게 음료를 서비스하기 위한 과정 및 소요 시간은 다음과 같다.
   1. 손님으로부터 알바가 주문 받은 후 바리스타에게 주문서 전달. (1s)
   2. 주문서를 받은 바리스타가 주문서에 알맞는 음료를 만든 후 알바에게 음료 전달. (10s)
   3. 음료를 받은 알바가 손님에게 음료 전달. (1s)



### Synchronous Blocking

1. 각 알바가 손님으로부터 음료 주문 받고 바리스타에게 주문서를 넘긴다.
2. 알바는 다른 손님의 주문을 받지 않으면서 바리스타가 현재 만들고 있는 음료가 나올 때 까지 기다린 후 서빙한다. 

한 손님당 12s가 걸리기 때문에 총 2명의 알바가 100명의 손님에게 서비스 하는데 600s가 걸림.

가장 안좋은 점은 4명의 바리스타 중 한번에 최대 2명의 바리스타만 커피를 만든다는 것이다.



### Synchronous Non-Blocking

1. 각 알바가 손님으로부터 음료 주문 받고 바리스타에게 주문서를 넘긴다.
2. 알바는 주문서를 넘긴 뒤 나올 음료를 기다리지 않고 계속해서 손님의 주문을 받는다.
3. 손님의 주문을 받다가 음료가 나온다면 이를 해당 손님에게 전달한다.

알바가 음료가 나오는 것을 기다릴 필요가 없기 때문에 주문을 미리 많이 받을 수 있고, 4명의 바리스타가 동시에 커피를 계속 만들 수 있다.

결론적으로 100명의 손님을 서비스하는 시간은 4명의 바리스타가 커피를 만드는 시간과 비슷해진다. (약 250s)

바리스타의 수를 더 늘린다면 초당 처리할 수 잇는 손님의 수가 늘어날 것이다.



### Asynchronous Blocking

1. 각 알바가 손님으로부터 음료 주문을 받은 후 바리스타에게 주문서를 넘긴다.
2. 재료 준비 및 로스팅에 집중하던 바리스타가 본인의 일을 끝내고 음료를 만든다. 
   (주문서를 넘김과 동시에 음료를 만드는 행위가 시작되지 않는다는 것 즉, 바리스타와 알바가 시간을 서로 맞추지 않는다는 것을 표현하고 싶었다.)
3. 알바는 다른 손님의 주문을 받지 않고 바리스타로부터 건내진 주문서에 해당하는 음료가 나오기를 기다린다.
4. 음료가 나온다면 이를 알맞는 손님에게 서비스한다.

Synchronous Blocking 방식과 비슷한 듯 하지만, 바리스타는 주문서가 들어오는 순간에 음료를 제조하지 않는다는 점에서 이 방식보다 전체 손님 처리 속도가 조금 더 느릴 수 있다. (600s + a)



### Asynchronous Non-Blocking

1. 각 알바가 손님으로부터 음료 주문 받은 후 바리스타에게 주문서를 넘긴다.
2. 재료 준비 및 로스팅에 집중하던 바리스타가 본인의 일을 끝내고 음료를 만든다. 
   (주문서를 넘김과 동시에 음료를 만드는 행위가 시작되지 않는다는 것 즉, 바리스타와 알바가 시간을 서로 맞추지 않는다는 것을 표현하고 싶었다.)
3. 알바는 음료가 나오기를 기다리지 않고 계속 주문을 받거나 자신의 할 일을 하면서 음료가 나온다면 이를 알맞는 손님에게 서빙한다.

Synchronous Non-Blocking 방식과 비슷한 듯 하지만, 바리스타는 주문서가 들어오는 순간에 음료를 제조하지 않기 때문에 이 방식보다 전체 손님 처리 속도가 조금 더 느릴 수 있다. (250s + a) 
