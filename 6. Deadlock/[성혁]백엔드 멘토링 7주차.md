1. 교착상태(Deadlock) 이란 무엇이고, 어떤 조건들이 갖춰진 경우에 발생하는지 알려주세요.
2. 자원 할당 그래프(Resource Allocation Graph)를 사용해서 Deadlock을 표현해보시오.
3. Deadlock을 다루기 위한 방법(ignorance, prevention, ...)은 이와 같이 여러가지가 있는데 각각의 장단점은 무엇이고 현재 어떤 방법이 가장 많이 쓰이고 있고 왜 그런지 알려주세요.



---



# Introduction to Deadlock



모든 프로세스는 그들의 실행을 완료하기 위해 리소스가 필요하다. 그러나 리소스는 순차적으로 부여된다.

1. 프로세스는 리소스를 요구한다.
2. 만약 리소스가 이용 가능하다면 OS가 리소스를 부여하고, 그렇지 않으면 프로세스를 기다리도록 한다.
3. 프로세스는 리소스를 사용하고 완료시 릴리스 한다.



Deadlock은 각 컴퓨터 프로세스가 다른 프로세스에 할당되는 리소스를 기다리는 상황이다. 이 상황에서는, 필요한 리소스가 다른 리소스가 릴리스되기를 기다리고 있는 몇몇 다른 프로세스에 의해 유지되기 때문에 프로세스가 실행되지 않는다.



![os Deadlock](https://static.javatpoint.com/operating-system/images/os-deadlock.png)

다음 그림은 P1이 P2에 할당된 R2가 릴리스 되기를 기다리며 중지되고, P2 또한 P3에 할당된 R3가 릴리스 되기를 기다리며 중지되고, P3 역시 P1에 할당된 R1이 릴리스 되기를 기다리며 중지된 상황이다. 이 시나리오에서는 진행 중인 프로세스가 없으며, 모두 기다리는 중이다. 모든 프로세스가 block되었기 때문에 컴퓨터가 응답하지 않게 된다.



### Difference between Starvation and Deadlock

#### Deadlock

1. Deadlock은 프로세스가 차단되지 않고 프로세스가 진행되지 않는 상황이다.

2. Deadlock은 무한 대기 상태이다.

3. 모든 Deadlock은 항상 Starvation이다.(?)

4. 요청된 리소스는 다른 프로세스에 의해 차단되었다.

5. Deadlock은 상호배제, 보류 및 대기, 비선점 및 순환 대기가 동시가 동시에 발생한다.

   (비선점 : 프로세스가 자원을 할당 받았을 경우, 자원을 스스로 반납할 때까지 계속 그 자원을 사용하도록 허용하는 정책)

#### Starvation

1. Starvation은 우선 순위가 낮은 프로세스가 차단되고 우선 순위가 높은 프로세스가 진행되는 상황이다.
2. Starvation은 오랜 기다림이지만 무한하지는 않다.
3. 모든 Starvation은 Deadlock일 필요는 없다.
4. 요청된 리소스는 우선 순위가 더 높은 프로세스에서 계속 사용된다.
5. 통제되지 않은 우선 순위와 자원 관리로 인해 발생한다.



### Deadlock에 필요한 조건

#### Mutual Exclusion

* 리소스는 상호 배타적인 방식으로만 공유할 수 있다. 두 프로세스가 동시에 동일한 리소스를 사용할 수 없는 경우를 의미한다.

#### Hold and Wait

* 프로세스는 다른 리소스를 보유하면서 동시에 일부 리소스를 기다린다.

#### No preemption

* 한 번 스케줄된 프로세스는 완료될 때까지 실행된다. 그동안 스케줄러는 다른 프로세스를 스케줄링할 수 없다.

#### Circular Wait

* 마지막 프로세스가 첫 번째 프로세스가 보유하고 있는 자원을 기다리도록 모든 프로세스는 순환 방식으로 자원을 대기해야 한다.



# Strategies for handling Deadlock

## 1. Deadlock Ignorance

Deadlock Ignorance는 모든 매커니즘 중에서 가장 널리 사용되는 접근 방식이다. 이것은 주로 많은 운영체제에서 사용되어진다. 이 접근에서, OS는 데드락이 결코 발생하지 않는다고 가정한다. 쉽게 말해 데드락을 무시한다고 가정한다. 이 접근은 사용자가 브라우징과 기타 모든 일반적인 용도로만 사용하는 single end user system에 가장 적합하다. 정확함(올바름)과 퍼포먼스는 항상 tradeoff 관계에 있다. 윈도우와 리눅스와 같은 OS는 주로 성능에 포커스를 둔다. 그러나, 데드락이 100번 중 한번 발생하는 상황에서 매번 데드락 핸들링 매커니즘을 사용한다면 시스템의 성능은 감소하기 때문에, 데드락 핸들링 매커니즘을 매번 사용하는 것은 불필요하다. 이 시스템의 유형에서, 교착 상태의 경우 사용자는 단순히 컴퓨터를 재시작해야만 한다. 윈도우와 리눅스는 주로 이 접근을 사용한다.

## 2. Deadlock prevention

데드락은 상호 배제, 보류 및 대기, 비선점 그리고 순환 대기가 동시에 유지되는 경우에만 발생한다. 언제든 이 네 조건 중 하나를 위반할 가능성이 있다면 데드락은 시스템에서 결코 발생하지 않는다. 네 가지 조건 중 하나가 실패해야 한다는 이 접근 뒤에 있는 아이디어는 매우 간단하지만 시스템에서 물리적 구현에 있어서 큰 논쟁이 있을 수 있다. 

---

만약 우리가 네 다리로 서 있는 테이블을 가지고 데드락을 시뮬레이션 한다면 우리는 데드락을 유발하는 동시에 발생하는 4가지 조건을 가지고 네 다리를 시뮬레이션할 수 있다. 

그러나, 테이블 다리 중 하나가 부러지면 테이블은 확실하게 넘어질 것이다. 교착상태도 마찬가지다. 만약 네 가지 필수 조건 중 하나를 위반할 수 있고 함께 발생하지 않도록 할 수 있다면 교착상태를 예방할 수 있다.

각 조건을 어떻게 예방할 수 있는지 알아보자 !



### Mutual Exclusion

리소스 관점에서 상호 섹션은 리소스가 둘 이상의 프로세스에서 동시에 사용될 수 없다는 사실이며 이는 충분히 공정하지만 데드락의 주요 원인입니다. 리소스가 둘 이상의 프로세스에 의해 동시에 사용되어져왔다면 프로세스는 다른 자원을 기다리지 않았을 것이다.

그러나, 상호 배타적인 방식으로 동작하는 리소스를 위반할 수 있다면 데드락은 방지할 수 있다.

#### Spooling

프린터와 같은 장치의 경우 spooling이 작동할 수 있다. 각 프로세스로부터의 작업을 저장하는 프린터와 관련된 메모리가 있다. 그후에, 프린터는 모든 작업들을 모으고 FCFS에 따라 각각의 작업을 프린트한다. 이 매커니즘을 사용함으로서, 프로세스는 프린터를 기다릴 필요가 없고, 무엇을 하던지 계속할 수 있다. 그후에, 생산될 때 출력을 수집한다.



![os Deadlock Prevention Spooling](https://static.javatpoint.com/operating-system/images/os-deadlock-prevention-spooling.png)



비록, spooling이 상호배제를 위반하기 위한 효과적인 접근 방법일 수 있지만 그것은 두 종류의 문제를 겪는다.

1. 모든 리소스에 적용될 수 없다.
2. 일정 시간이 지나면, 해당 spool에 공간을 얻기 위해 프로세스 간에 경쟁조건이 발생할 수 있다.

리소스가 충분히 공정하지 않고 성능에 심각한 문제를 발생할 수 있기 때문에 동시에 둘 이상의 프로세스에서 리소스를 사용하도록 강제할 수 없다. 그러므로, 실질적으로 프로세스에 대한 상호 배제를 위반할 수 없다.



### Hold and Wait

보류 및 대기 조건은 프로세스가 리소스를 보유하고 다른 리소스가 작업을 완료하기를 기다리는 경우이다. 교착 상태는 순환 순서로 하나의 자원을 보유하고 다른 자원을 기다리는 프로세스가 둘 이상 있을 수 있기 때문에 발생한다.

그러나, 프로세스가 리소스를 보유하지 않거나 기다리지 않는 매커니즘을 찾아야 한다. 즉, 실행이 시작되기 전에 프로세스에 필요한 모든 리소스가 할당되어야만 한다. 프로세스는 실행이 한번 시작되면 리소스를 기다리지 않아야 한다.

**!(Hold and wait) = !hold or !wait (negation of hold and wait is, either you don't hold or you don't wait)**

이것은 프로세스가 초기에 모든 자원을 선언할 경우 실질적으로 구현할 수 있다. 그러나 이것은 실용적으로 들리지만 프로세스가 초기에 필요한 리소스를 결정할 수 없기 때문에 컴퓨터 시스템에서는 수행할 수 없다.

프로세스는 CPU에 의해 실행된 일련의 명령이다. 각 명령어는 여러 시간에 여러 리소스를 요구할지도 모른다. 필요는 OS에 의해 고쳐질 수 없다.

접근 방식의 문제는 다음과 같다.

1. 실질적으로 불가능하다.

2. 일부 프로세스가 리소스를 매우 오랫동안 보유할 수 있기 때문에 기아 상태가 될 가능성이 높다.

   

### No Preemption

데드락은 프로세스가 한번 시작되면 멈출 수 없다는 사실 때문에 발생한다. 그러나, 만약 데드락을 유발하는 프로세스로부터 자원을 떨어뜨린다면 우리는 데드락을 예방할 수 있다. 

프로세스에 의해 사용되어지고 있는 리소스를 떨어뜨리는 것은 지금까지 수행한 모든 작업이 일관되지 않을 수 있기 때문에 전혀 좋은 접근 방식이 아니다.

어떠한 프로세스에 의해 프린터가 사용되어지고 있다고 가정해보자. 만약 우리가 프린터를 해당 프로세스로부터 떨어뜨리고 그것에 몇몇 다른 프로세스를 할당한다면 프린트되어져왔던 모든 데이터는 일관되지 않을 수 있고 효과적이지 않을 수 있다 또한 이전 프로세스가 떠난 지점에서 프린팅을 시작할 수 없는 프로세스는 성능 비효율을 유발한다. 이렇게 하면 단일 프로세스가 다른 프로세스에서 사용 중인 리소스를 요청할 수 없으며 사이클이 형성되지 않는다.



### Circular Wait

순환 대기를 위반하기 위해, 우리는 각각의 리소스에 우선순위 번호를 할당할 수 있다. 프로세스는 더 적은 우선순위 리소스를 요청할 수 없다. 



![os Deadlock Prevention](https://static.javatpoint.com/operating-system/images/os-deadlock-prevention.png)



모든 방법들 중에, 순환 대기를 위반하는 것은 실질적으로 구현될 수 있는 그 유일한 접근 방식이다.

## 3. Deadlock avoidance

데드락 회피에서, OS는 OS가 실행되는 매 단계에 있어서 시스템이 안전한 상태인지 혹은 불안전한 상태인지를 체크한다. 프로세스는 시스템이 안전한 상태가 될 때까지 계속된다. 일단 시스템이 불안전한 상태로 이동하면, OS는 한 단계를 역추적해야만 한다. 쉽게 말해서, OS는 시스템에서 할당이 데드락을 유발하지 않게 하기 위해서 각각의 할당을 리뷰한다. 

---

데드락 회피 상황에서, 어떤 리소스에 대한 요청은 시스템의 결과 상태가 시스템에서 데드락을 유발하지 않는다면 승인될 것이다. 시스템의 상태는 안전한 상태와 불안전한 상태를 지속적으로 체크한다.

데드락을 회피하기 위해서, 프로세스는 실행을 완료하기 위해 프로세스가 요청할 수 있는 최대 리소스 수를 OS에게 말해야만 한다 

가장 간단하고 유용한 접근 방식은 프로세스가 필요할 수 있는 각 유형의 최대 리소스 수를 선언해야 한다는 것이다. 데드락 회피 알고리즘은 절대 순환 대기 조건이 되지 않기 위해서 리소스 할당을 검사한다.

시스템의 리소스 할당 상태는 사용 가능하고 할당된 리소스의 인스턴스와 프로세스에 의해 요구된 리소스의 최대 인스턴스에 의해 정의될 수 있다.

**Resources Assgined**

| Process | Type 1 | Type 2 | Type 3 | Type 4 |
| :------ | :----- | :----- | :----- | :----- |
| A       | 3      | 0      | 2      | 2      |
| B       | 0      | 0      | 1      | 1      |
| C       | 1      | 1      | 1      | 0      |
| D       | 2      | 1      | 4      | 0      |

**Resources still needed**

| Process | Type 1 | Type 2 | Type 3 | Type 4 |
| :------ | :----- | :----- | :----- | :----- |
| A       | 1      | 1      | 0      | 0      |
| B       | 0      | 1      | 1      | 2      |
| C       | 1      | 2      | 1      | 0      |
| D       | 2      | 1      | 1      | 2      |

1. E = (7 6 8 4) 
2. P = (6 2 8 3) 
3. A = (1 4 0 1) 

위의 표와 벡터 E,P,A는 시스템의 자원 할당 상태를 나타낸다. 시스템에는 4가지 프로세스와 4가지 유형의 리소스가 있다. 표 1은 각 프로세스에 할당된 각 리소스의 인스턴스를 보여준다.

표 2는 각 프로세스가 여전히 필요로 하는 리소스의 인스턴스를 보여준다. 벡터 E는 시스템에 있는 각 리소스의 총 인스턴스를 나타낸다.

벡터 P는 프로세스에 할당된 리소스의 인스턴스를 나타낸다. 벡터 A는 사용하지 않는 리소스의 수를 나타낸다.

시스템이 교착 상태에 빠지지 않고 모든 프로세스에서 요청한 모든 리소스를 할당할 수 있는 경우 시스템 상태를 안전이라고 한다.

시스템이 모든 프로세스의 요청을 수행할 수 없으면 시스템 상태를 안전하지 않는 상태라고 한다.

교착 상태 방지 접근 방식의 핵심은 리소스에 대한 요청이 있을 때 결과 상태가 안전한 상태인 경우에만 요청이 승인되어야 한다는 것이다.

## 4. Deadlock detection and recovery

이 접근 방식은 프로세스가 교착상태에 빠지게 하고 시스템에서 교착상태가 발생하는지 여부를 주기적으로 확인한다. 만약 교착상태가 발생하면 데드락을 제거하기 위해 시스템에 몇몇 recovery method를 적용한다. 

---

이 접근 방식에서, OS는 데드락을 회피하거나 예방하기 위한 어떠한 매커니즘도 적용하지 않는다. 그러므로 그 시스템은 데드락이 분명히 발생할 것이라고 가정한다. 데드락을 제거하기 위해서, OS는 교착 상태가 있는지 시스템을 주기적으로 확인한다. 교착 상태를 발견한 경우 OS는 일부 복귀 기술을 사용하여 시스템을 복구한다.

OS의 주요 작업은 교착 상태를 감지하는 것이다. OS는 자원 할당 그래프의 도움으로 교착 상태를 감지할 수 있다.



![OS Deadlock Detection and Recovery](https://static.javatpoint.com/operating-system/images/os-deadlock-detection-and-recovery.png)

하나의 인스턴스화된 리소스 타입에서, 시스템에서 사이클이 형성된다면 분명이 데드락이 있을 것이다. 반면에, 다중 인스턴스 리소스 타입 그래프에서는, 사이클을 발견하는 것은 충분하지 않다. 자원 할당 그래프를 할당 행렬과 요청 행렬로 변환하여 시스템에 안전하게 알고리즘을 적용해야만 한다.



### For Resource

#### Preempt the resource

우리는 자원(프로세스)의 소유자로부터 자원 중 하나를 빼앗아 실행을 완료하고 이 자원을 더 빨리 해제할 것이라는 기대와 함께 다른 프로세스에 이를 제공할 수 있다. 빼앗을 자원을 선택하는 것은 약간 어려울 것이다. 

#### Rollback to a safe state

시스템은 다양한 상태를 거쳐 교착 상태가 된다. 운영체제는 시스템을 이전 안전 상태로 롤백할 수 있다. 이를 위해 OS는 모든 상태에서 체크 포인팅을 구현해야 한다. 교착 상태에 빠지는 순간 모든 할당을 롤백하여 이전 안전 상태로 전환한다.

### For Process

#### Kill a process

프로세스를 종료하면 문제를 해결할 수 있지만 더 큰 문제는 어떤 프로세스를 종료할지 결정하는 것이다. 일반적으로 운영체제는 지금까지 가장 적은 양의 작업을 수행한 프로세스를 종료한다.

#### Kill all process

이것은 제안할 수 있는 접근 방식이 아니지만 문제가 매우 심각해지면 구현할 수 있다. 모든 프로세스를 종료하면 모든 프로세스가 처음부터 다시 실행되기 때문에 시스템의 비효율이 발생한다.

![OS Deadlock Detection and Recovery 1](https://static.javatpoint.com/operating-system/images/os-deadlock-detection-and-recovery1.png)

# Resource Allocation Graph

자원 할당 그래프는 시스템 상태의 회화적 표현이다. 이름에서 알 수 있듯이 자원 할당 그래프는 일부 리소스를 보유하거나 일부 리소스를 기다리는 모든 프로세스에 대한 완전한 정보이다.

또한 사용 가능하거나 프로세스에서 사용 중인지 여부에 관계없이 모든 리소스의 모든 인스턴스에 대한 정보를 포함한다.

리소스 할당 그래프에서 프로세스는 원으로 표시되고 리소스는 직사각형으로 표시된다. vertex와 edge의 종류를 자세히 알아보자.



![OS Resource Allocation Graph](https://static.javatpoint.com/operating-system/images/os-resource-allocation-graph.png)



Verticle은 주로 리소스와 프로세스의 두 가지 유형으로 나뉜다. 그들 각각은 다른 모양으로 표시된다. 원은 프로세스를 나타내고 사각형은 리소스를 나타낸다. 리소스에는 둘 이상의 인스턴스가 있을 수 있다. 각 인스턴스는 직사각형 내부의 점으로 표시된다.



![OS Resource Allocation Graph 1](https://static.javatpoint.com/operating-system/images/os-resource-allocation-graph1.png)



RAG의 Edge는 두 가지 유형으로 나뉜다. 하나는 할당을 나타내고 다른 하나는 리소스에 대한 프로세스의 대기를 나타낸다. 위의 이미지는 각각을 보여준다. 화살표의 꼬리 부분이 리소스에 대한 인스턴스에 연결되고 머리 부분이 프로세스에 연결된 경우 리소스는 프로세스에 할당된 것으로 표시된다. 머리가 리소스를 가리키고 있는 동안 화살표의 꼬리가 프로세스에 연결되어 있으면 프로세스가 리소스를 기다리는 것으로 표시된다.



![OS Resource Allocation Graph 2](https://static.javatpoint.com/operating-system/images/os-resource-allocation-graph2.png)



![OS Resource Allocation Graph 3](https://static.javatpoint.com/operating-system/images/os-resource-allocation-graph3.png)

P1, P2, P3 세 개의 프로세스와 R1, R2 두 유형의 리소스를 고려해봐. 리소스에는 각각 개의 인스턴스가 있다. 그래프에 따르면 R1은 P1에서 사용 중이고 P2는 R2를 잡고 R1을 기다리고 있으며 P3은 R1과 R2를 기다리고 있다. 그래프에 사이클이 형성되지 않기 때문에 그래프는 교착 상태가 없다.



![OS Resource Allocation Graph 4](https://static.javatpoint.com/operating-system/images/os-resource-allocation-graph4.png)

