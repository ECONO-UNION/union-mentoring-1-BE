```
### 1. 과거 우리는 메인 메모리에 여러 프로세스를 로드하기위해 메모리를 파티션으로 나누어 프로세스를 로드하는 방식인 파티셔닝 기법을 사용하였다. 그렇다면 파티셔닝(동적, 정적) 기법으로 프로세스에 메모리를 할당할 때 생기는 문제점은 무엇이고 어떤 해결방법이 있는가?



### 2. 단편화를 해결하는 방법 중 하나인 Compaction은 많은 오버헤드를 발생시킨다고 알려져있다. Compaction과 달리 많은 오버헤드를 발생시키지 않고 외부 단편화를 극적으로 없애는 기법은 Paging 기법인데 이 기법이 나오게 된 이유와, 원리, 장단점에 대해서 설명해주세요.



### 3. 메모리를 물리적이 아닌 논리적 내용의 단위인 세그먼트로 분할하여 메모리를 관리하는 기법인 Memory Segmentation에 대해서 알려주시고, Paging 기법이랑 비교해주세요



### 4. 가상 메모리는 무엇이고 왜 나오게 되었나요? 그리고 이를 통해 우리는 무엇을 할 수 있을까요?



### 5. 가상 메모리 시스템에서 자주 사용되는 기법 중 하나인 Demand Paging은 무엇이고 왜 사용하게 되었으며 Demand Paging의 핵심 알고리즘인 페이지 교체 알고리즘에 대해서 장단점을 포함해 소개해주세요. 
```



## 고정 파티셔닝 vs 동적 파티셔닝

### 고정 파티셔닝

여러 프로세스를 주 메모리에 로드하는데 사용할 수 있는 가장 간단한 기술 중 하나는 고정 분할 또는 연속 메모리 할당이다. 

이 기술에서 메인 메모리는 같거나 다른 크기의 파티션으로 나뉜다. 운영체제는 항상 첫 번째 파티션에 있고 다른 파티션은 사용자 프로세스를 저장하는데 사용할 수 있다.

메모리는 연속 적인 방식에서 프로세스에 할당된다.



**1. 내부 단편화**

프로세스의 크기가 파티션의 전체 크기보다 작으면 파티션의 일부 크기가 낭비되고 사용되지 않은 상태로 유지됨. 이것은 메모리 낭비이며 내부 단편화라고 한다.

아래 이미지에서 볼 수 있듯이 4MB 파티션은 3MB 프로세스만 로드하는 데 사용되고 나머지 1MB는 낭비된다.

**2. 외부 단편화**

다양한 파티션의 전체 사용되지 않은 공간은 사용 가능한 공간이 있지만 연속적인 형태가 아닌 경우에도 프로세스를 로드하는 데 사용할 수 없다.

아래 이미지와 같이 각 파티션의 나머지 1MB 공간은 4MB 프로세스를 저장하는 단위로 사용할 수 없다. 프로세스를 로드할 수 있는 충분한 공간이 있음에도 불구하고 프로세스가 로드되지 않다.

**3. 프로세스 규모의 제한**

프로세스 크기가 최대 크기의 파티션 크기보다 크면 해당 프로세스를 메모리에 로드할 수 없다. 따라서 가장 큰 파티션의 크기보다 클 수 없는 프로세스 크기에 제한이 부과될 수 있다.

**4. 멀티프로그래밍 정도가 낮다**

다중 프로그래밍의 정도는 단순히 동시에 메모리에 로드할 수 있는 최대 프로세스 수를 의미하는데 고정 파티셔닝에서는 멀티프로그래밍의 정도가 고정되어 있고 프로세스의 크기에 따라 파티션의 크기를 변경할 수 없기 때문에 매우 적다.



![image-20210917140207670](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210917140207670.png)



### 동적 파티셔닝

이 기술에서 파티션 크기는 초기에 선언되지 않고 프로세스 로딩 시 선언된다.

각 파티션의 크기는 프로세스의 크기와 같습니다. 파티션 크기는 내부 단편화를 방지할 수 있도록 프로세스에 따라 다르다.

![image-20210917140423762](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210917140423762.png)

**1. 내부 단편화 없음**

동적 파티셔닝에서 파티션은 프로세스의 필요에 따라 생성된다는 사실을 감안할 때 파티션에 사용되지 않은 나머지 공간이 없기 때문에 내부 조각화가 없다

**2. 프로세스의 크기에 대한 제한 없음**

고정 파티셔닝에서는 연속 메모리가 부족하여 가장 큰 파티션 크기보다 큰 프로세스를 실행할 수 없었는데 여기서 동적 분할에서는 파티션 크기가 프로세스 크기에 따라 결정되기 때문에 프로세스 크기를 제한할 수 없었다.

**3. 다중 프로그래밍의 정도는 동적이다**

내부 단편화가 없기 때문에 파티션에 사용되지 않은 공간이 없으므로 더 많은 프로세스가 동시에 메모리에 로드될 수 있다.



#### 동적 파티셔닝의 단점

**외부 단편화**

**복잡한 메모리 할당**

고정 파티셔닝에서는 파티션 목록이 한 번 만들어지고 변경되지 않지만 동적 파티셔닝에서는 새 프로세스에 할당될 때마다 파티션 크기가 변경되기 때문에 할당 및 할당 해제가 매우 복잡하다. 

동적 메모리 할당에서 할당과 할당 해제가 매우 자주 수행되고 파티션 크기가 매번 변경되기 때문에 OS에서 모든 것을 관리하기가 매우 어렵다.



## 단편화를 해결하기 위한 방법들

### Compaction 이란

![image-20210917141409710](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210917141409710.png)

6번 프로세스가 들어갈 크기를 만들기 위해서 2,3,4, 번을 옮기기 위해서는 일시적인 공간으로 복사를 해야한다. 그리고 이 메모리에 다시 복사해서 가져와야 할 것이다. 즉 secondary storage 하드디스크에다가 임시로 복사해서 저장을 해야하는데, 하드디스크는 엄청 느리기 때문에 실행가능한 방법은 아니다.

비어있는 공간을 연속적인 공간으로 만들고 움직이는 작업을 compaction이라고 한다.

compaction 방법은 외부 단편화를 줄일 수 있는 방법이 될수 있긴 한데 메모리 복사를 하는데 있어서 반드시 I/O 문제가 나오게 된다. 하드디스크가 병목이 되기 때문에 좋은 방법이 아니라고 판단하여 새로운 방법을 찾게 된다.



### first fit, best - fit, worst - fit 

외부 단편화를 줄이기 위해 프로세스를 메모리에 fit 하게 넣는 방법을 생각하게 된다.

trace data를 만들어서 시뮬레이션 프로그램을 돌려 성능을 측정 할 수 있는데, 방법을 3가지로 했다.

- fisrst fit 최초적합

최초 적합은 가장 최초로 발견되는 공간에다가 할당하는 방법이다. 남은 메모리를 순차적으로 앞에서부터 탐색하게 되는데, 이 프로세스가 들어갈 수 있는 공간 중 최초에 발견되 공간에다가 배치하는게 최초적합이다.

![image-20210917144054943](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210917144054943.png)

- best fit 최적 적합

가장 잘 맞는데에 넣으려고 다 비교해보는 것이다. 어차피 남는 공간이 생기지만 가급적이면 작게 만들자는 목표다.

![image-20210917144156161](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210917144156161.png)

- worst fit 최악 적합

가장 큰 공간, 즉 가장 남는 공간에다가 넣는게 worst fit 이다. 자투리를 크게 만들어 다른 프로세스를 또 거기 들어갈 확률을 높인다는 목표다. 자투리 공간이 너무 좁으면 재사용하지못하고 쓸데 없다는 생각이다.

![image-20210917144359943](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210917144359943.png)



세 가지 방법에 대한 효율성 비교

first fit 하고 best fit은 속도나 메모리 사용률 측면에서 worst fit 보다 좋은것으로 시뮬레이션에 나타났다. 

first fit하고 best fit 하고 비교를 했을때 메모리 효율에 그렇게 차이가 없다고 나왔지만 알고리즘의 복잡도를 생각해 볼때 만약 공간이 많다라고 가정하면 첫 번째꺼를 선택하는 first fit이 빠르다. 라는 결론이 나오게 된다. (best fit 과 worst fit은 모두다 비교해봐야 되기 때문에)



-> 그러나 어떤 알고리즘을 쓰던 외부 단편화는 발생한다. 외부 단편화로 인한 값비싼 메모리를 낭비하는것이 문제라는 것이다. 가장 최악의 경우에는, 두개의 프로세스 사이사이에 hole 이 발생할 수도 있어서 이런 작은 hole 들을 다 뭉쳐보면 여러 프로세스를 돌릴 수 있는 큰 메모리일수 도 있다. N개의 블럭이 할당되었을 때 0.5 개의 블록이 단편화때문에 손실 될 수 있다는 50퍼센트 규칙이라고 불린다.



#### 외부 단편화 문제 때문에 쓸모없는 공간이 너무 많다! 메모리는 엄청 비싼 자원이므로 새로운 방법을 생각해내자 -> paging



지금까지의 방법은 프로세스 크기별로 메모리를 할당하는 가변 분할이다. 모든 프로세스 크기가 동일한게 아니니까 어떻게 집어넣든 프로세스 크기가 제각각일 경우 외부 단편화 발생을 막을 수 없고 메모리를 많이 낭비하게 된다. 그래서 나온게 페이징으로 메모리를 고정된 크기로 할당시키는 것이다. 이러한 방법을 고정 분할이라고 한다.



## paging 기법

논리적 주소를 동일한 크기로 자르고, 물리적 주소도 동일한 크기로 자른다. 

![image-20210917153653526](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210917153653526.png)



이렇게 하면 연속적으로 배치를 안해도 된다. 이렇게 하면 하나의 프로세스를 굳이 연속적으로 배치할 필요가 없다어서 외부 단편화가 발생하지 않는다.



#### 내부 단편화 vs 외부 단편화

동일한 크기로 잘라서 굳이 연속적으로 배치하지 않아도 되기 때문에 외부 단편화는 이제 없어졌다. 하지만 프로세스가 이 페이지 크기에 맞게끔 딱 동작하지 않으면 자투리 공간이 생긴다. 만약 프로세스 A가 페이지 한 블록의 크기보다 작은 추가적인 크기를 가지고 있다면 남는 공간이 생긴다. 이렇게 공감이 남을 경우 이를 내부 단편화라고 한다.



외부 단편화는 크기가 다른 것을 할당하고 반납하는 과정에서 hole이 남는다고 했는데 이걸 외부 단편화라고 하는거고  지금 현재 그 외부 단편화를 해결하기 위해서 메모리를 동일한 크기로 잘라서 그 동일한 크기로 할당을 하게 되면 하나의 프로세스를 연속적인 공간에다가 할당할 필요 없이 아무 공간에다가 넣을 수 있다. 이러면 외부 단편화는 없어지지만 약간의 자투리가 남는데 이것을 내부 단편화라고 부른다.

외부 단편화에 비해 내부 단편화는 얼마 되지 않는다. 



### 페이지 테이블

메모리 적재가 연속적이지 않고 여기에 있다 저기에 있다 흩어져 있으니 프로그램을 문제 없이 수행하기 위해 일직선으로 쭉 수행시켜줄 수 있도록 도와주기 위해 페이지 테이블이라는게 있다.

![image-20210917171403988](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210917171403988.png)

프로세스가 메모리에 올라가도 순차적으로 수행되어야 하는데 메모리에 적재된 page들을 순차적으로 수행하면 메이플 페이지2 -> 유튜브 페이지0 .... 순이 됭버리니까 하나의 프로세스가 정상적으로 수행되지 않는다. 즉 유트브 페이지0 다음에는 유트브 페이지1이 연달아 실행될 수 있도록, 페이지 테이블이 순서에 맞는 물리적 메모리 위치를 찾아준다. 죽 프로세스마다 페이지 테이블을 갖고 있는 것이다.

![image-20210917171652509](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210917171652509.png)

페이지 테이블은 배열과 같다. 배열처럼, 인덱스가 페이지 번호를 가리키고 그 배열에 담고 있는 숫자가 매핑할 프레임 번호인 것이다.



### 페이지의 크기와 논리적 주소 구성

- 논리적 주소 : CPU에 의해서 생성되는 주소체계
- 물리적 주소 : RAM에 실질적으로 로드되는 주소

페이지 매핑에 맞춰 CPU로부터 생성되는 논리적 주소는 페이지 번호와 페이지 오프셋으로 구성되어 있습니다.

- 페이지 번호

매핑을 위해 page와 frame 은 번호를 갖는다. page0 이라고 할 때 순서에 해당하는 숫자 0이 번호인 것이다. 논리 메모리를 자른 것은 page라 하니까 논리 주소는 페이지 번호를 포함하고 있다. 논리메모리를 자른 페이지를 셀 때에는 page number라고 하고 물리메모리를 자른 프레임을 셀 때에는 frame number라고 한다. 하지만 덩어리인 page만으로는 정확한 주소를 표기할 수 없다. 이를 위해 오프셋이 있다.

- 페이지 오프셋

하나의 페이지가 4KB 라고 가정하면 이 페이지는 주소로 따지면 0번지에서 2의 12승까지 값의 번지까지 있는 것이다. 그렇게 해서 page 번호 말고 page 내의 번호를 우리가 offset이라고 부른다.



32비트 프로세서라고 가정하고 하나의 페이지가 4KB라고 할 때 하나의 프로세스가 가질 수있는 페이지의 최대 개수는 ![image-20210917194223776](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210917194223776.png)

2의 20승개가 될 것이다.

프로세스마다 페이지 테이블을 가지니까 하나의 프로세스만 생각해도 2의 20승의 페이지가 있는 것이다. 여러 프로세스가 돌아가게 되면 용량을 너무 많이 잡아먹는 단점이 있다. 실행파일이 커지게 되면 하드디스크에서 다 읽어가지고 메모리에 읽어 실행할 준비를 하는데 시간이 오래 걸릴게 된다.

속도를 빠르게 하려면 CPU내에 있는 MMU엗가 넣어야 속도가 빠랄진다. 그렇지만 MMU에다가 4메가바이트 메모리에 집어넣는건 너무 비싸져서 불가능하게 되고 램에 둘 수 밖에 없게 된다.

## segmentation

프로그램의 주소 공간을 의미있는 단위로 자르는 것을 말한다.

프로세스를 작은 단위로 분할할 수 있고 작게는 프로그램을 구성하는 함수 하나하나를 세그먼트로 지정할 수도 있고, 크게는 프로그램 전체를 하나의 세그먼트로 정의할 수도 있다.

세그멘테이션은 프로세스를 세그먼트의 집합으로 생각한다. 사실 하나의 프로세스가 동작하려면 기본적으로 코드, 데이터, 스택 세 가지의 세그먼트는 항상 가지고 있다. 그리고 더 들어가 보면 코드에서도 main 함수가 있을 수 있고, 다른 함수들이 있을 수도 있고, 다른 루틴이 있을 수도 있다. 데이터를 보아도 어떤 구조체가 있을 수도 있고 배열도 있을 수 있다. 그래서 세그먼테이션은 물리적인 크기의 단위가 아닌 논리적 내용의 단위(의미가 같은)로 자르기 때문에 세그먼트들의 크기는 일반적으로 같지 않다.

segmentation 기법은 분할된 조각들의 크기가 균일하지 않기 때문에 연속할당 시 발생했던 문제들이 그대로 발생할 가능성이 있다.

segment에는 논리적 주소가 지정되는데 논리적 주소는 <segment number, offset>으로 구성된다. 이를 segment table이라고 한다. 세그먼트 각각의 길이가 동일하지 않을 수 있기 때문에 테이블에는 offset이란 개념으로 table의 길이를 포함한다. 페이징 기법에서는  페이지의 크기가 균일하기 때문에 offset 값이 결국 페이지 크기였지만, 세그먼트 기법은 offset 이 결정되어야 한다는 단점이 존재한다.

따라서 우리는 세그먼테이션과 페이징의 기법을 모두 장점만 사용하고자 한다. 세그먼테이션은 보호와 공유 면에서 효과적이고 페이징은 외부 단편화 문제 해결에 효과적이므로 두 가지 모두를 사용할 수 있으면 좋을 것이다. 따라서 세그먼트를 페이징 하는 방법을 취한다.

![image-20210917202448307](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210917202448307.png)

프로세스를 처음에 세그먼트 단위로 자른다. 의미 있는 단위로 나누게 되면 보호와 공유를 하는 측면에 이점을 가질 수 있게 된다. 하지만 외부 단편화가 발생할 수 있다. 그래서 우리는 잘라진 세그먼트를 다시 일정 간격인 페이지 단위로 자르는 페이징 방법을 취한다. 그래서 메모리에 적재하면 페이징의 일정 단위로 다시 잘렸기 때문에 외부 단편화가 발생하지 않는다. 하지만 이와 같은 경우에는 테이블을 두 가지를 모두 거쳐야 하므로 속도 면에서 조금 떨어질 수 있다.



## 가상 메모리

메인 메모리의 크기가 한정되어 있으므로 물리적인 메모리 크기보다 크기가 큰 프로세스를 실행시킬 수 없다. 예로 100MB 메인 메모리에서 200MB 크기의 프로세스를 실행할 수 없게 되는 것이다. 그렇다면 메인 메모리보다 크기가 큰 프로세스를 실행시키고 싶으면 어떻게 해야 할까? 이런 방법은 매우 비효율적일 것이다. 그래서 나온 방법이 바로 가상 메모리이다.

**필요한 부분만 메모리에 올림으로써 메인 메모리에 올라가는 프로세스의 크기를 줄인다. 프로세스 이미지를 모두 메모리에 올릴 필요가 없는 것이다.**

물리적인 메모리에 프로세스를 적재하는데에는 운영체제가 관여하는 부분이 없었다. 하지만 가상 메모리에 대한 문제는 운영체제가 전적으로 관여한다. 가상 메모리는 메모리 관리에서 다뤄진대로, 메모리에 프로세스가 더 이상 적재될 수 없을 때, swapped out 되는 메모리이다.



### demand paging 

요구 페이징(Demand Paging)은 프로세스의 이미지를 backing store에 저장한다. backing store는 swap device로 하드웨어의 부분인데 페이지를 임시로 보관하는 공간이다. 프로세스는 페이지의 조합이기 때문에 필요한 페이지만 메모리에 올린다. 이를 요구되는 페이지만 메모리에 올린다는 의미로 요구 페이징이라고 부른다.

요청이 왔을 때 페이지 단위로 메모리에 올리는 기법을 말한다. I/O 양이 감소되고, 빠른 응답시간을 보이고, 더 많은 사용자를 수용할 수 있게 된다. 즉, 페이지 단위로 프로세스가 적재하는 상태이며, 프로세스의 모든 페이지가 올라가 있지 않고 순간 순간마다 필요한 페이지들이 메모리에 적재되어 있고, 나머지는 모두 가상 메모리에 적재되어 있는 상태를 말한다. 

![img](https://t1.daumcdn.net/cfile/tistory/224F144E590E8AD91B)



그런데 요구 페이징 기법을 사용하면 페이지가 메모리에 올라와있는 것도 있고 올라가지 않고 backing store에 보관되어 있는 것도 존재한다. 따라서 페이지 테이블을 작성할 때 이를 구분해줄 도구가 필요하다. 그래서 valid 비트 필드를 페이지 테이블에 추가한다. 1과 0의 값으로 메모리에 적재되어 있는지 없는지를 구분할 수 있다.



### page fault

주소 변환 시에 invalid bit이 있으면 페이지 폴트가 발생한다.

로드된 프로세스로부터 요청이 온 논리적 주소가 물리적 메모리에 존재하지 않으면 MMU가 page fault trap을 발생시키고, 이때 cpu 제어권이 운영체제에게 넘어간다.



![image-20210917175705679](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210917175705679.png)

1. 로드된 프로세스 M으로부터 논리적 주소 요청이 들어온다. 
2. page table에 주소가 올라와 있지 않으므로 page fault handler에 의해 소프트웨어 인터럽트가 발생한다.
3. 디스크로 접근하여 요청한 주소에 해당하는 부분을 찾는다.
4. 비어있는 페이지 프레임을 찾는다.
5. 비어있는 페이지 프레임이 존재하지 않는 경우 디스크로부터 메모리로 적재한다.
6. load 작업이 끝나면 페이지 테이블에 valid 로 기록한다.



### 페이지 교체

요구 페이징은 요구되어지는 페이지만 backing store에서 가져와 메인 메모리에 적재하는 방법이다. 필요한 페이지만 메인 메모리에 올리므로 메모리의 낭비를 줄이는 방법으로 사용되었다. valid 비트를 추가한 페이지 테이블과 필요하지 않은 페이지를 보관하는 backing store를 가지고 기능을 수행할 수 있다. 하지만 프로그램 실행이 계속 진행되게 되면 요구 페이지가 늘어나게 되고 언젠가는 메모리가 가득 차게 될 것이다. 페이지를 backing store에서 가져와 메모리에 올려야 되는데 메모리에 자리가 없는 것이다. 이럴 경우 메인 메모리에 있는 특정 페이지를 내보내야할 필요가 있다. 그 자리에 필요한 다른 페이지를 올려야한다. 이를 페이지 교체라고 한다.



- **최적 페이지 교체(Optimal Page Replacement)**
  앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 기법.
  미래에 어떤 페이지가 어떠한 순서로 참조될지 미리 알고있다는 전재하에 알고리즘을 운영하므로 현실적으로 구현이 어렵다. 페이지 부재율이 가장 낮은 효율적인 알고리즘이다.
- **FIFO(First-In-First-Out) 알고리즘**
  페이지 교체시 물리적 메모리에 가장 먼저 올라온 페이지를 우선적으로 내쫓는다.
  페이지의 향후 참조 가능성을 고려하지 않고, 물리적 메모리에 들어온 순서대로 내쫓을 대상을 선정하기때문에 비효율적인 상황이 발생할 수 있다.
  `빌레이디의 모슨(Belady's Anomaly)현상`이 발생할 수 있다.
  (빌레이디 모순 현상 : 페이지 프레임 수가 많으면 페이지 부재수가 줄어드는 것이 일반적이지만, 페이지 프레임수를 증가시켰음에도 페이지 부재가 더 많이 일어나는 현상을 의미)

![content01](https://eunhyejung.github.io/assets/contents/os_content10.PNG)

- **LRU(Least Recent Used) 알고리즘**
  최근에 가장 오랫동안 사용하지 않은 페이지를 교체하는 기법.
  (마지막 참조시점이 가장 오래된 페이지 교체)
  `시간지역성(temporal locality)`의 성질을 고려해 고안된 알고리즘이다.
  (시간 지역성 : 최근에 참조된 페이지가 가까운 미래에 다시 참조될 가능성이 높은 성질)
  (Counter)나 스택과 같은 별도의 하드웨어가 필요하며, 시간적인 오버헤드가 발생된다. (실제로 구현이 어려움)
  (Counter : 각 페이지별로 존재하는 논리적인 시계(Logical Clock)로, 해당 페이지가 사용될때마다 0으로 클리어 시킨 후 시간을 증가시켜 시간이 가장 오래된 페이지를 교체)

![content02](https://eunhyejung.github.io/assets/contents/os_content11.PNG)

- **LFU(Least-Frequently-Used) 알고리즘**
  페이지의 참조횟수로 교체할 페이지를 결정하는 기법.
  즉, 물리적 메모리 내에 존재하는 페이지 중에서 과거에 참조 횟수(reference count)가 가장 적었던 페이지를 내쫓고 그 자리에 새로 참조될 페이지를 적재한다.
  LFU 알고리즘은 LRU 알고리즘보다 오랜시간 동안의 참조 기록을 반영할 수 있다는 장점이 있다.

LRU, LFU 알고리즘은 페이지의 최근 참조 시각 및 참조 횟수를 소프트웨어적으로 유지해야 하므로 알고리즘의 운영에 오버헤드가 발생한다.