# 프로세스와 스레드 

----

> ##  Mentor's Q
>
> 1. Process와 Thread는 무엇인가 ? (어떤 문제를 해결하기 위해 나오게 되었는지에 대한 조사 필수)
> 2. MultiThread와 MultiProcess의 장단점
> 3. MultiThread와 MultiProcess의 각각의 접근방식은 어떤 서비스를 개발하는 데 더 적절한가 ? 그리고 그 이유는 무엇인가?
> 4. Blocking과 Non-Blocking 연산 수행간에 MultiThread와 MultiProcess중 어떤 것이 더 빠르고, 어떠한 경우에 왜 빠른지에 대해 공유 자원의 측면에서 설명하라

---

## 1. Process, Thread는 무엇인가?

**keyword**

- 실행 단위 - CPU core에서 실행하는 하나의 단위로 프로세스와 스레드를 포괄하는 개념
- 프로세스 - 하나의 스레드만 가지고 있는 단일 스레드 프로세스
- 동시성 - 한 순간에 여러가지 일이 아니라, 짧은 전환으로 여러가지 일을 동시에 처리하는 것처럼 보여지는 것

### About Process

**프로세스**는 **컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램을 말한다.** 종종 task라는 용어와 거의 같은 의미로 쓰이고, 여러개의 프로세서를 사용하는 것을 이후 다룰 [멀티프로세싱](https://ko.wikipedia.org/wiki/멀티프로세싱)이라고 하며 같은 시간에 여러 개의 프로그램을 띄우는 시분할 방식을 [멀티태스킹](https://ko.wikipedia.org/wiki/멀티태스킹)이라고 한다. [프로세스 관리](https://ko.wikipedia.org/wiki/프로세스_관리)는 OS의 중요한 부분이 되었다.

프로그램은 뭡니까 ? 하드 디스크 등에 저장 되어 있는 실행코드, 

프로세스는요 ? 프로그램을 구동하여 프로그램 자체와 프로그램의 상태가 메모리 상에서 실행되는 작업 단위를 지칭

예를 들면, 하나의 프로그램을 여러 번 구동하면 여러 개의 프로세스가 메모리 상에서 시랳ㅇ되는 것입니다.

#### state of process

[커널](https://ko.wikipedia.org/wiki/커널_(컴퓨팅)) 내에는 준비 큐, 대기 큐, 실행 큐 등의 [자료 구조](https://ko.wikipedia.org/wiki/자료_구조)가 있으며 커널은 이것들을 이용하여 프로세스의 상태를 관리한다.

- 생성(create) : 프로세스가 생성되는 중이다.
- 실행(running) : 프로세스가 CPU를 차지하여 명령어들이 실행되고 있다.
- 준비(ready) : 프로세스가 CPU를 사용하고 있지는 않지만 언제든지 사용할 수 있는 상태로, CPU가 할당되기를 기다리고 있다. 일반적으로 준비 상태의 프로세스 중 우선순위가 높은 프로세스가 CPU를 할당받는다.
- 대기(waiting) : 보류(block)라고 부르기도 한다. 프로세스가 입출력 완료, 시그널 수신 등 어떤 사건을 기다리고 있는 상태를 말한다.
- 종료(terminated) : 프로세스의 실행이 종료되었다.

#### state transition of process

![img](%5BMTR%5D%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80%20%EC%8A%A4%EB%A0%88%EB%93%9C.assets/R800x0)

운영체제 학부 수업시간이나, 정보처리기사를 준비하며 많이 보았던 그림이다. 자세히 살펴보도록 하면, 하나의 프로그램이 실행되면 그 프로그램에 대응되는 프로세스가 생성되어 준비리스트(자료구조가 궁금해 = 정답 queue)의 끝에 들어간다. 준비 리스트상의 다른 프로세스들이 CPU를 할당받아 준비리스트에서 나가면 그 프로세스는 준비리스트의 앞부분으로 가게되고 언젠가 cpu를 사용할 수 있게 된다. 

- 디스패치(dispatch)

```
dispatch (processname) : ready → running
```

- 보류(block)

```
block (processname) : running → blocked
```

- 깨움(wakeup)

```
wakeup (processname) : blocked → ready
```

- 시간제한(timeout)

```
timeout(processname) : running -> ready
```

#### process memory structure

![img](%5BMTR%5D%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80%20%EC%8A%A4%EB%A0%88%EB%93%9C.assets/dfPyq.jpg)

- text section : 실행 코드 저장
- data section : 전역 변수 저장
- heap section : 프로그램 실행 중 동적으로 할당되는 메모리
- stack section : 함수를 호출할 때, 임시 데이터 저장장소 (함수 매개변수, 복귀주소 및 지역변수들)

당연한 이야기지만 text section 같은 경우엔 크기가 고정 되기 때문에 프로그램 실행 시간 동안 크기가 변하지 않는다. 그러나 스택 및 힙 섹션은 프로그램 실행 중 동적으로 줄어들거나 커질 수 있다.

과정은 간단하게 함수가 호출 되면 함수 매개변수 , 지역변수 및 복귀주소를 포함하는 활성화 레코드(activation record)가 스택에 푸쉬 되고, 함수에서 제어가 돌아오게 되면 스택에서 활성화 레코드가 팝된다.

**프로그램 그 자체는 프로세스가 아님을 강조**한다. **프로그램**은 명령어 리스트를 내용으로 가진 디스크에 저장된 파일과 같은 **수동적인 존재이다(passive entity)**

이와는 대조적으로 **프로세스**는 다음에 실행할 명령어를 지정하는 프로그램 카운터와 관련 자원의 집합을 가진 **능동적인 존재이다(active entity)**

실행파일이 메모리에 적재될 때, 프로그램은 프로세스가된다.

이거 뭐 꽃이라고 불러줄때 비로소 꽃이된다 이런거 있지 않았나 그거랑 비슷한 것 같다.

### About Thread

**스레드**(thread)는 어떠한 프로그램 내에서, 특히 [프로세스](https://ko.wikipedia.org/wiki/프로세스) 내에서 실행되는 흐름의 단위를 말한다. 일반적으로 한 프로그램은 하나의 스레드를 가지고 있지만, 프로그램 환경에 따라 둘 이상의 스레드를 동시에 실행할 수 있다. 이러한 실행 방식을 [멀티스레드](https://ko.wikipedia.org/wiki/멀티스레딩)(multithread)라고 한다.

![img](%5BMTR%5D%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80%20%EC%8A%A4%EB%A0%88%EB%93%9C.assets/220px-Multithreaded_process.svg.png)

스레드는 어떠한 프로그램 내에서, 특히 프로세스 내에서 실행되는 흐름의 단위를 말한다. 일반적으로 하나의 애플리케이션(프로그램)은 하나 이상의 프로세스를 가지고 있고, 하나의 프로세스는 반드시 하나 이상의 스레드를 갖는다. 즉 프로세스를 생성하면 기본적으로 하나의 (메인)스레드가 생성되는 셈이다.

#### Compare Thread and process

프로세스는 실행될 때 운영체제로부터 각각 독립된 메모리 영역을 할당받지만 스레드는 한 프로세스 내에서 동작되는 흐름으로 프로세스 내에서 stack영역만 별도로 할당 받고, 부모 프로세스의 Code, Data, Heap 영역은 공유한다.

즉, 프로세스내에서 자식 스레드들은 서로의 주소공간이나 자원을 공유하면서 실행될 수 있다. 프로세스는 독립적으로 실행되며 각각 별개의 메모리를 차지하고 있는 것과 달리, 멀티스레드는 프로세스 내의 메모리를 공유하기 때문에 프로세스 간의 전환속도보다 스레드간의 전환속도가 빠르다 

게다가 CPU가 여러 개일 경우 각각의 CPU가 스레드 하나씩을 담당하는 방법으로 속도를 높일 수 있다. 여러 스레드가 실제 시간상으로 동시에 수행될 수 있기 때문이다.

스레드는 각각의 스레드 중 어떤 것이 실행될지 그 순서를 알 수가 없다. 이것은 원래 프로그램의 의도와 다를 수 있다. 이에 대한 결과로 스레드의 실행 조건에 따라 결과가 다르게 나오므로, 오류가 발생했을 때, 원인을 찾기가 힘들다. 이를 경쟁조건이라고 하는데, 문제를 막기 위해 세마포어와 같은 방법을 통해 공유 데이터에 접근하는 스레드의 개수를 한 개 이하로 유지하는 방법을 사용할 수 있다.

#### Kind of Thread

스레드를 지원하는 주체에 따라 2가지로 나눌 수 있다.

### 사용자 레벨 스레드 (User-Level Thread)

사용자 스레드는 커널 영역의 상위에서 지원되며 일반적으로 사용자 레벨의 라이브러리를 통해 구현되며, 라이브러리는 스레드의 생성 및 스케줄링 등에 관한 관리 기능을 제공한다. 동일한 메모리 영역에서 스레드가 생성 및 관리되므로 속도가 빠른 장점이 있는 반면, 여러 개의 사용자 스레드 중 하나의 스레드가 시스템 호출 등으로 중단되면 나머지 모든 스레드 역시 중단되는 단점이 있다. 이는 커널이 프로세스 내부의 스레드를 인식하지 못하며 해당 프로세스를 대기 상태로 전환시키기 때문이다.

### 커널 레벨 스레드 (Kernel-Level Thread)

[커널](https://ko.wikipedia.org/wiki/커널_(컴퓨팅)) 스레드는 운영체제가 지원하는 스레드 기능으로 구현되며, 커널이 스레드의 생성 및 스케줄링 등을 관리한다. 스레드가 시스템 호출 등으로 중단되더라도, 커널은 프로세스 내의 다른 스레드를 중단시키지 않고 계속 실행시켜준다. [다중처리기](https://ko.wikipedia.org/wiki/다중처리기) 환경에서 커널은 여러 개의 스레드를 각각 다른 처리기에 할당할 수 있다. 다만, 사용자 스레드에 비해 생성 및 관리하는 것이 느리다.



## 2. MultiThread, MultiProcess

## 멀티 프로세스

멀티 프로세스란 하나의 애플리케이션을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하도록 하는 것이다.

![img](https://miro.medium.com/max/1400/0*Ckn6QtkZgOQ2m1xO.png)

멀티프로세스는 다음과 같은 특징을 지닌다.

- 안정성이 좋다. 장애전파가 안된다. (엥 ? 이거 어디서 많이 본거 아니냐 모놀커널,마크커널 ㅋㅋ)
- 구현이 비교적 간단, 각 프로세스들이 독립적으로 동작하며 자원이 서로 다르게 할당된다.
- 프로세스 간 통신을 하기 위해 IPC를 통해야한다.
- 메모리 사용량이 많다.
- 스케쥴링에 따른 문맥교환이 많아지고, 성능 저하의 우려가 있다.

## 멀티 스레드

멀티 스레드란 하나의 애플리케이션을 여러 개의 스레드로 구성하여 하나의 스레드가 하나의 작업을 처리하도록 하는 것이다. 일반적으로 멀티스레드르 사용하는 이유는 사용자와 상호작용하는 애플리케이션에서 단일 스레드로 Network 또는 DB 와 같은 긴 작업(Long-running task) 을 수행하는 경우 해당 작업을 처리하는 동안 사용자와 상호작용이 불능인 상태가 될 수 있기 때문이다. 그림을 살펴보면 두개의 스레드가 서로에게 방해주지 않고, 각자 할일을 하는 모습을 보여주고 있다.

![img](https://miro.medium.com/max/1400/0*Nkp_jRDjVXFjwlJ2.png)

멀티 스레드는 다음과 같은 특징을 지닌다.

- 응답성이 좋다. 프로그램의 일부분(자식 스레드)이 오류 또는 긴 작업으로 인해 중단되어도 프로그램이 계속 적으로 수행된다.
- 자원 공유가 쉽다. 스레드들은 부모 프로세스의 자원과 메모리를 공유 할 수 있다.
- 프로세스를 할당하는 것보다 스레드를 할당하는 것이 비용이 적다.
- 멀티프로세서 구조에서 각각의 스레드가 다른 프로세서에서 병렬로 수행될 수 있다.
- 구현 및 테스트, 디버깅이 어렵다
- 너무 많은 스레드 사용은 오버헤드를 발생시킨다.
- 동기화에  주의해야 한다.
- 자식 스레드 중 하나에 문제가 생긴경우 전체 프로세스에 영향을 줄 수 있다.

#### Multithread VS Multiprocess

멀티 스레드는 멀티 프로세스에 비해 상당한 이점을 가지는 반면 위험 부담도 따른다. 그 이유를 알아보자.

자원의 효율성증대

멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우 프로세스를 생성하여 자원을 할당하는 비용이 적고, 스레드는 프로세스 내의 메모리를 공유하기 때문에 독립적인 프로세스와 달리 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어든다.

응답 시간 단축 및 처리 비용 감소

프로세스간 IPC를 사용하여 통신하는 것은 상대적으로 비용이 크다. 하지만 스레드는 프로세스의 메모리 영역을 공유하여 스레드 간의 통신 비용이 적게 든다. 또한 프로세스간의 Context Switching은 느린 반면 쓰레드간의 Context Switching 은 빠른데, 그 이유는 Context Switching 시 스레드는 Stack 영역만 처리하면 되기 때문이다.

멀티 스레드의 안정성 문제

여러 개의 스레드가 동일한 데이터 공간(Critical Section)을 공유하면서 이들을 수정한다는 점에 필연적으로 생기는 문제이다. 멀티 프로세스의 프로그램은 문제가 생기면 해당 프로세스가 중단되거나 중단 시키고 다시 시작 하면된다. 하지만 멀티 스레드 방식의 프로그램에서는 하나의 스레드가 자신이 사용하던 데이터 공간을 망가뜨린다면, 해당 데이터 공간을 공유하는 모든 스레드를 망가뜨릴 수 있다.

**Critical Section:** 임계 구역(critical section) 또는 공유변수 영역은 둘 이상의 스레드가 동시에 접근해서는 안되는 공유 자원(자료 구조 또는 장치)을 접근하는 코드의 일부를 말한다.

위키 : 프로세스 히스토리 https://en.wikipedia.org/wiki/Process_(computing)#History

