1. Process와 Thread는 뭔가? (특히 이들이 어떠한 문제를 해결하기 위해 나오게 되었는지에 대해서 꼭 조사하세요.)
2. MultiThread와 MultiProcess의 장단점을 각각 조사하고, 각 접근 방식은 어떠한 서비스를 개발하는데 더 적절하고 왜 그런가?
3. Blocking과 Non-Blocking 연산 수행간에 MultiThread와 MultiProcess 중 어떤 것이 더 빠르며, 어떠한 경우에 왜 빠른지에 대해서 공유 자원의 측면에서 알려달라.



# Process vs Thread

---

-코다-

#### 키워드

1. 실행단위 - cpu core에서 실행하는 하나의 단위로 프로세스와 스레드를 포괄하는 개념
2. (부연 설명잉 없는) 프로세스 - 하나의 스레드만 가지고 있는 단일 스레드 프로세스
3. 동시성 - 한 순간에 여러가지 일이 아니라, 짧은 전환으로 여러가지 일을 동시에 처리하는 것처럼 보이는 것(문맥 교환)



### Process & Thread

프로그램이 프로세스가 되기 위해서는 메모리에 올라가야 한다. 



실행 명령을 포함하는 코드영역

static이나 글로벌 변수를 담는 데이터 영역

동적 메모리를 위한 힙 영역

지역변수, 매개변수, 반환 값 등등 일시적인 데이터를 담는 스택 영역



![스크린샷 2021-08-06 오전 10.51.45](/Users/sunghyuki/Desktop/Econovation/유니온 멘토링/과제 그림 파일/스크린샷 2021-08-06 오전 10.51.45.png)



한 프로세스가 실행 상태가 되기 위해서 cpu를 점유하고 있으면 다른 프로세스는 실행 상태에 있을 수가 없다. 그래서 다수의 프로세스를 동시에 실행하기 위해 여러 개의 프로세스를 시분할로, 즉 짧은 텀을 반복하면서 전환해서 실행 -> 문맥 교환  

프로세스의 컨텍스트 스위칭은 굉장히 피곤하고 힘든 작업이다.



![스크린샷 2021-08-06 오전 10.53.07](/Users/sunghyuki/Desktop/Econovation/유니온 멘토링/과제 그림 파일/스크린샷 2021-08-06 오전 10.53.07.png)

-> 경량화된 프로세스 버전인 스레드의 등장

-> 하나의 프로세스 안에 다수의 스레드가 있을 때 공유되는 자원이 있기 때문에 경량화된 이라고 부른다.

-> 스레드는 코드, 데이터, 힙 영역을 공통된 자원으로 사용하고 스택 부분만을 따로 가지고 있다.

-> 공유되는 자원이 있기 때문에 컨텍스트 스위칭이 일어날 때 캐싱 적중률이 올라간다. (쉽게 말해 모조리 다 빼고 다시 다 넣을 필요가 없다)



### Multi-process & Multi-thread

멀티 프로세스와 멀티 스레드 이 두 가지 개념이 모두 처리방식의 일종이라는 겁니다.

그러니까 한 어플리케이션에 대한 처리 방식이라고 생각하면 편하다.



![스크린샷 2021-08-06 오전 11.01.13](/Users/sunghyuki/Desktop/Econovation/유니온 멘토링/과제 그림 파일/스크린샷 2021-08-06 오전 11.01.13.png)

상황 가정) 여러 사용자가 로그인을 요청하는 상황

한 프로세스는 매번 하나의 로그인만 처리할 수 있기 때문에 동시 처리를 할 수 없다.

그래서 부모 프로세스가 fork()를 해서 자식 프로세스를 여러 개 만들어서 일을 처리하도록 한다.

이때 자식 프로세스는 부모와 별개의 메모리 영역을 확보하게 된다.



반면 스레드는 한 프로세스 내에서 구분지어진 실행단위이다.

프로세스 내에서 분리해서 여러 스레드로 나뉘어서 실행단위가 나뉘어지면 그게 멀티 스레드가 된다.

한 어플리케이션에 대한 작업의 단위가 나뉘어질 때가 많은데 이때 각각의 스레드가 그 작업들을 담당하게 된다.



![스크린샷 2021-08-06 오전 11.02.51](/Users/sunghyuki/Desktop/Econovation/유니온 멘토링/과제 그림 파일/스크린샷 2021-08-06 오전 11.02.51.png)

차이점

- 프로세스는 독립적이기 때문에 IPC를 통해서 통신을 해야 한다.
  - 그러니까 같은 작업을 두 명이 두 개의 다른 회의실에서 진행을 하다가 논의 할 일이 생기면 밖으로 나와서 이야기를 하고 다시 들어가야 한다.
- 자원이 소모적이고 개별 메모리 차지
- 컨텍스트 스위칭 비용도 크다
- 하지만 개별 독립적이기 때문에 동기화 작업에 신경을 덜 써도 된다.



* 스레드는 공유자원이 많으므로 긴밀하게 연결되어 있다.
* 그만큼 동기화도 신경을 많이 써야 하지만 공유된 자원으로 메모리가 효율적이고 통신 비용도 절감된다.
  * 두 명이 한 회의실에 앉아서 일을 처리하고 있기 때문에 논의할 일이 생기면 말만 걸면 된다.
* 컨텍스트 스위칭 비용도 적다.



이렇게만 보면 멀티 스레드가 더 좋아보이는데 멀티 프로세스를 이용하는 이유?

![스크린샷 2021-08-06 오전 11.08.10](/Users/sunghyuki/Desktop/Econovation/유니온 멘토링/과제 그림 파일/스크린샷 2021-08-06 오전 11.08.10.png)

예전에 인터넷 익스플로러를 사용하다가 이런 오류 화면을 만난 적이 한번쯤은 있을 것이다.

한 탭에 오류가 생기면 전체 창이 꺼져버린다. 

이것은 멀티스레드를 이용했기 때문이다. 긴밀하게 연결되어 있기 때문에 한 스레드, 한 탭에 문제가 생기면 전체 프로세스에 영향을 끼친다.



반면 구글 크롬은 멀티 프로세스를 이용하기 때문에 멀티탭 간의 영향을 덜 받는다.



### Multi-core

동시성과 병렬처리

![스크린샷 2021-08-06 오전 11.19.47](/Users/sunghyuki/Desktop/Econovation/유니온 멘토링/과제 그림 파일/스크린샷 2021-08-06 오전 11.19.47.png)

싱글코어를 가진 cpu가 실행단위를 처리할 때는 동시에 여러 가지가 진행되기 위해서 빠른 텀으로 전환이 되면서 실행됨. -> 동시성(여러 실행단위를 번갈아 실행하면서 동시에 일어나는 것처럼 보이게 하는 것)

짧은 순간에 cpu의 시간을 분할해서 동시에 하는 것처럼 보이게 한다.



멀티코어는 병렬처리, 물리적으로 여러 코어를 사용해서 다수의 실행단위를 한순간에 처리할 수 있게 해준다.  



번외) 리눅스에서 프로세스와 스레드

![스크린샷 2021-08-06 오후 12.07.37](/Users/sunghyuki/Desktop/Econovation/유니온 멘토링/과제 그림 파일/스크린샷 2021-08-06 오후 12.07.37.png)



-> 리눅스 커널에서는 프로세스와 스레드를 동일하게 봅니다.

스레드는 사용자 스레드와 커널 스레드로 나뉜다.

각 스레드를 담당하는 레벨이 하나는 사용자의 레벨이고 하나는 커널레벨이다.

리눅스는 일대일 모델 -> 사용자 스레드당 커널 스레드 하나가 매칭

light weight process -> 메모리를 공유

![스크린샷 2021-08-06 오후 1.57.18](/Users/sunghyuki/Desktop/Econovation/유니온 멘토링/과제 그림 파일/스크린샷 2021-08-06 오후 1.57.18.png)

사용자 레벨 입장에서 보면 이 스레드 그룹 아이디가 pid로 보여지고, 커널 입장에서 보면 tid가 pid로 인식된다.



-김고래-

### Process

* 프로그램 : 실행되기 전 상태의 명령어, 코드 및 정적인 데이터의 묶음
* 프로세스 : 실행 중인 Program, 운영체제로부터 시스템 자원을 할당 받는 작업의 단위



![스크린샷 2021-08-06 오후 2.09.41](/Users/sunghyuki/Desktop/Econovation/유니온 멘토링/과제 그림 파일/스크린샷 2021-08-06 오후 2.09.41.png)



![스크린샷 2021-08-06 오후 2.10.13](/Users/sunghyuki/Desktop/Econovation/유니온 멘토링/과제 그림 파일/스크린샷 2021-08-06 오후 2.10.13.png)



프로세스의 상태는 PCB 블록으로 표현

* PID : 프로세스 식별자
* 프로세스 상태 : new, ready, running, waiting, halted 등
* 프로그램 카운터 : 다음 실행할 명령어의 주소
* 스케줄링 정보 : 우선순위 등



 ### Thread

![스크린샷 2021-08-06 오후 2.12.11](/Users/sunghyuki/Desktop/Econovation/유니온 멘토링/과제 그림 파일/스크린샷 2021-08-06 오후 2.12.11.png)



#### Multi Thread

* 프로세스의 자원을 공유
* 향상된 응답성
* 컨텍스트 스위칭 비용이 적음
* 자원을 공유하는 만큼, 충돌을 주의(Thread-safe하게!)
* Ex) Web Server



#### Multi Process

* 하나의 작업을 여러 개의 프로세스가 처리
* 프로세스 간 통신(IPC, interprocess communication)
* 컨텍스트 스위칭 비용이 큼
* 자식 프로세스 중 하나가 문제가 생겨도 다른 프로세스에 영향이 없음
  * Ex) 구글 크롬



-쪼밀리와 오구-

### 멀티태스킹

우리는 컴퓨터를 사용하면서 동시에 여러가지 작업들을 한다.

CPU는 한순간에 하나의 프로세스만 실행할 수 있다. 

작업관리자를 확인하면 현재 돌리고 있는 스레드와 프로세스의 수를 알 수 있듯이 한순간에 여러가지 작업을 하고 있는 것처럼 보인다.

-> 운영체제가 짧은 시간에 수십번에서 수천번 실행할 프로세스를 교체하고 있기 때문에, 우리는 동시에 여러 개의 작업이 실행되고 있다고 느끼는 것



#### 멀티 프로세스

작업에 흐름이 여러 갈래 생기는 경우, 여러 개의 프로세스로 하나의 작업을 구성할 수 있음

 각 프로세스가 각각의 메모리 영역을 가지고 있기 때문에 비효율이 발생

![스크린샷 2021-08-06 오후 2.38.24](/Users/sunghyuki/Desktop/Econovation/유니온 멘토링/과제 그림 파일/스크린샷 2021-08-06 오후 2.38.24.png)

![스크린샷 2021-08-06 오후 2.39.26](/Users/sunghyuki/Desktop/Econovation/유니온 멘토링/과제 그림 파일/스크린샷 2021-08-06 오후 2.39.26.png)

첫 번째 프로세스를 진행하는 동안 메모리 영역이 실제로 일을 하는 코어로 로딩이 되는데 다음 프로세스로 넘어갈 때 메모리 영역을 따로 가지고 있기 때문에 기존에 쓰던 것을 내리고 다른 코드들을 로딩하는 작업이 필요함.

![스크린샷 2021-08-06 오후 2.40.16](/Users/sunghyuki/Desktop/Econovation/유니온 멘토링/과제 그림 파일/스크린샷 2021-08-06 오후 2.40.16.png)

두 번째 같은 작업을 하기 위한 프로세스인데 다른 프로세스의 정보를 이용하기 위해서 통신이 필요



#### 멀티 스레드

 ![스크린샷 2021-08-06 오후 2.42.38](/Users/sunghyuki/Desktop/Econovation/유니온 멘토링/과제 그림 파일/스크린샷 2021-08-06 오후 2.42.38.png)

 ![스크린샷 2021-08-06 오후 2.43.16](/Users/sunghyuki/Desktop/Econovation/유니온 멘토링/과제 그림 파일/스크린샷 2021-08-06 오후 2.43.16.png)

![스크린샷 2021-08-06 오후 2.43.49](/Users/sunghyuki/Desktop/Econovation/유니온 멘토링/과제 그림 파일/스크린샷 2021-08-06 오후 2.43.49.png)

![스크린샷 2021-08-06 오후 2.44.20](/Users/sunghyuki/Desktop/Econovation/유니온 멘토링/과제 그림 파일/스크린샷 2021-08-06 오후 2.44.20.png)

멀티 스레드의 경우 같은 코드 데이터 힙 영역을 공유하고 있기 때문에 램에 적재되었다가 뺄 것이 없기 때문에 컨텍스트 스위칭 비용이 적다

![스크린샷 2021-08-06 오후 2.47.04](/Users/sunghyuki/Desktop/Econovation/유니온 멘토링/과제 그림 파일/스크린샷 2021-08-06 오후 2.47.04.png)



#### 멀티 코어

![스크린샷 2021-08-06 오후 2.47.40](/Users/sunghyuki/Desktop/Econovation/유니온 멘토링/과제 그림 파일/스크린샷 2021-08-06 오후 2.47.40.png)

![스크린샷 2021-08-06 오후 2.50.28](/Users/sunghyuki/Desktop/Econovation/유니온 멘토링/과제 그림 파일/스크린샷 2021-08-06 오후 2.50.28.png)

 ![스크린샷 2021-08-06 오후 2.51.30](/Users/sunghyuki/Desktop/Econovation/유니온 멘토링/과제 그림 파일/스크린샷 2021-08-06 오후 2.51.30.png)

-> 코어는 하나만 돌고 있다. 레지스터 값이 따로 적재가 되지 않았다.

-> 스레드 4 개가 시간 순으로 돌고 있다.



멀티 스레드 주의점

* 디버깅이 까다로움
* 한 프로세스 안의 스레드에 문제가 생기면 같은 프로세스 안의 스레드도 같이 문제가 생김
* 같은 데이터를 공유하기에, 데이터 동기화에 신경 써야함



잘못 코딩을 하면 남는 코어가 생기고, 한 코어에 스레드가 여러 개가 붙는 말도 안 되는 상황 발생

![스크린샷 2021-08-06 오후 2.54.16](/Users/sunghyuki/Desktop/Econovation/유니온 멘토링/과제 그림 파일/스크린샷 2021-08-06 오후 2.54.16.png)



### Multi Process와 Multi Thread의 접근 방식은 어떠한 서비스 개발에 적합할까?



# Thread(computing)

---



### 스레드의 역사

1965년 버클리 시분할 시스템에서 처음 쓰였다. 다만, 이 때에는 스레드라는 이름 대신에 프로세스라고 불렀다.

맥스 스미스(Max Smith)가 1970년대에 멀틱스(Multics)에 최초로 스레드를 구현했다. 이 스레드는 한 개의 무거운 프로세스 안에서 멀티 스택을 이용해 백그라운드 컴파일을 돕는 기능을 했다.

1970년 대 유닉스가 등장했다. 유닉스에서 말하는 프로세스란 순차적인 제어의 흐름에 덧붙여 가상주소 공간이 추가되었다. 즉 유닉스에서 프로세스란, 꽤 무거운 기계였다. 왜냐하면, 프로세스들은 메모리를 공유하지 않았고, 파이프나 시그널(signal)같은 것을 통해 상호 작용 했기 때문이다. 공유 메모리라는 개념은 나중에나 꽤 나중에 추가되었다.

시간이 지나, 유닉스 사용자들은 메모리를 공유할 수 있는 예전 방식의 프로세스를 그리워하기 시작했다. 이게 스레드의 발명을 이끌었다. (참고로, 예전 방식의 프로세스란 한개의 유닉스 프로세스에서 주소 공간을 공유하는 것을 말한다.) 예전 방식의 스레드는 기존 방식의 스레드가 무겁다(heavy-weight)며 이에 반대되는 의미로 ‘라이트웨이트(light-weight)’라고 불렸다.  이런 구분은 70년대 말에서 80년대 초에 마이크로커널(microkernels)이 나올 때까지 쓰였다.

## Processes, kernel threads, user threads, and fibers



### Processes

커널 레벨에서, 스레드는 스케줄링과 실행의 단위인 반면, 한 프로세스는 해당 프로세스의 메모리 및 파일 핸들과 같은 자원들을 공유하는 하나 또는 그 이상의 커널 스레드들을 포함한다. 

커널 스케줄링은 전형적으로 균일하게 선제적으로 또는 덜 일반적으로 협력하여 수행된다.

* 선점(Preemptive) 스케줄링 : 하나의 프로세스가 CPU를 할당받아 실행하고 있을 때 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법

사용자 레벨에서 런타임 시스템과 같은 프로세스는 자체적으로 여러 스레드의 실행을 예약할 수 있다. Erlang과 같이 데이터를 공유하지 않는 경우 일반적으로 유사하게 프로세스라고 부른다. 데이터를 공유하는 경우 일반적으로 스레드라고 하며, 특히 사전에 스케줄된 경우 더 그렇다.

협력적으로 스케줄된 사용자 스레드들은 fiber(light-weight한 실행 스레드, 협력적 멀티태스킹,실행하는 동안 다른 fiber를 실행하기 위해 스스로 양보하는 다중 작업 기법,을 사용)라고 부른다. 

사용자 스레드는 커널 스레드에 의해 다양한 방식(일대일, 다대일, 다대다)으로 실행될 수 있다. "light-weight process"라는 용어는 사용자 스레드 또는 사용자 스레드를 커널 스레드에 스케줄링하기 위한 커널 매커니즘을 다양하게 참고한다.

프로세스는 프로세스를 생성하고, destroying하고, 교환하는 것은 상대적으로 비용이 많이 들기 때문에 커널 스케줄링의 "heavy-weight"단위이다.

프로세스들은 운영체제에 의해 할당된 자원들을 가진다. 리소스는 메모리(코드 및 데이터 둘다), 파일 핸들, 소켓, 장치 핸들, 윈도우 그리고 프로세스 제어 블록이 포함한다.

프로세스는 process isolation에 의해 고립되고, 주소 공간 또한 이러한 파일 핸들이나 공유 메모리 세그먼트를 상속하거나 동일한 파일을 공유 방식으로 매핑하는 것과 같은 명시적 메서드를 통한 경우를 제외한 파일 리소스을 공유하지 않는다. 프로세스를 생성하고 destroy 하는 것은 리소스를 획득하고 반납해야 하기 때문에 상대적으로 비용이 많이 든다. 프로세스는 일반적으로 선점형 멀티 태스킹이며 프로세스 전환은 **캐시 플러시**(cache flushing)과 같은 문제로 인해 컨텍스트 전환의 기본 비용을 넘어 상대적으로 비용이 많이 든다.

* 캐시 플러시 : 
* process isolation : 한 프로세스가 다른 프로세스의 공간에 침범하는 것을 막는 기법



### Kernel threads

커널 스레드는 커널 스케줄링의 light-weight한 단위이다. 

최소한 한 커널 스레드는 각각의 프로세스 내에 존재한다. 만약 다수의 커널 스레드들이 한 프로세스 내에 존재할 경우, 커널 스레드들은 같은 메모리와 파일 리소스들을 공유한다. 만약 운영체제의 프로세스 스케줄러가 선점적이라면 커널 스레드는 선점적으로 멀티태스킹 되어 있다. 

커널 스레드는 스택, 프로그램 카운터를 포함한 레지스터 사본, 스레드 로컬 저장소를 제외하고 리소스를 소유하지 않으므로 생성과 destroy 비용이 상대적으로 저렴하다. Thread switching도 상대적으로 저렴하다. 컨텍스트 전환(레지스터와 스택 포인터 자장 및 복원)이 필요하지만, 가상 메모리를 변경하지 않으므로 캐시 친화적이다. 커널은 시스템의 각 logical core에 하나의 스레드를 할당할 수 있고 block된 스레드를 교체할 수 있다. 

그러나 커널 스레드는 교체하는 데 사용자 스레드보다 훨씬 오래 걸린다.



### User threads

스레드는 때때로 사용자 스레드라고 불리우는 사용자 공간 라이브러리에서 구현된다. 커널은 이를 인식하지 못하므로 사용자 공간에서 관리되고 예약된다. 몇몇 구현은 멀티 프로세서 시스템으로부터 오는 이점을 이행하기 위해 여러 커널 스레드 위에 사용자 스레드를 기반으로 한다. 가상 머신에 의해 구현된 사용자 스레드는 그린 스레드라고도 불리운다.

사용자 스레드 구현은 전형적으로 완전히 사용자 공간 안에 있으므로, 같은 프로세스 내에 있는 사용자 스레드들 사이의 컨텍스트 스위칭은 커널과의 상호 작용이 전혀 필요하지 않기 때문에 극도로 효율적이다.

컨텍스트 전환은 현재 실행 중인 사용자 스레드 또는 fiber에 의해 사용된 CPU 레지스터를 로컬로 저장한 다음 실행할 사용자 스레드 또는 fiber에 의해 필요로 하는 레지스터를 로드하여 수행할 수 있다. 스케줄링은 사용자 공간에서 발생하므로 스케줄링 정책은 프로그램의 작업 부하의 요구 사항에 더 쉽게 맞출 수 있다.

그러나 커널 스레드와 반대되는 사용자 스레드에서 blocking 시스템 호출의 사용은 문제가 될 수 있다. 만약 사용자 스레드 또는 fiber가 차단하는 시스템 콜을 사용한다면, 프로세스의 다른 사용자 스레드 또는 fiber는 시스템 호출이 반환될 때까지 실행할 수 없다. 이 문제의 일반적인 예는 I/O를 수행할 때이다. 대부분의 프로그램은 I/O를 동기적으로 수행하도록 작성된다. I/O 작업이 시작될 때, 시스템 콜이 만들어지고 I/O 작업이 완료될 때까지 반환되지 않는다. 중간에 전체 프로세스가 커널에 의해 "blocked" 되고 실행할 수 없으므로, 동일한 프로세스의 다른 사용자 스레드와 fiber가 실행되지 않는다.

이 문제에 대한 일반적인 해결 방법(특히 많은 그린 스레드 구현에서 사용됨)은 전체 프로세스가 아닌 호출 스레드를 차단하는 인터페이스를 내부적으로 사용하고 I/O 작업이 진행되는 동안 다른 사용자 스레드 또는 파이버를 스케줄링하여 제공하는 I/O API를 제공하는 것이다. 

다른 차단 시스템 호출에도 유사한 솔루션을 제공할 수 있습니다. 또는 동기식 I/O 또는 기타 차단 시스템 호출을 사용하지 않도록 프로그램을 작성할 수 있습니다(특히 람다 연속 및/또는 비동기식/대기 기본을 포함한 비차단식 I/O 사용).



### Fiber

fiber는 협력적으로 스케줄링되는 훨씬 가벼운 스케줄링 단위이다. 실행 중인 fiber는 다른 fiber가 실행될 수 있도록 명시적으로 "양보"해야 하므로 커널 또는 사용자 스레드보다 구현이 훨씬 쉽다. fiber는 동일한 프로세스의 모든 스레드에서 실행되도록 예약할 수 있다. 이를 통해 애플리케이션은 커널 스케줄러에 의존하는 대신 자체적으로 스케줄링을 관리하여 성능을 향상시킬 수 있다. OpenMP와 같은 병렬 프로그래밍 환경은 전형적으로 그들의 작업을 fiber를 통해 구현한다. fiber와 밀접하게 연관된 것은 coroutines이다, coroutines이 언어 수준 구성이라는 차별점이 있는, fiber가 시스템 수준 구성인 반면.



### Scheduling

#### 선점 스케줄링 vs 협력적 스케줄링

#### 싱글 프로세서 vs 멀티 프로세서

#### Threading models

#### 1:1 (kernel-level threading) 

#### *N*:1 (user-level threading)

#### *M*:*N* (hybrid threading)



### Threads and data synchronization

동일한 프로세스의 스레드는 동일한 주소 공간을 공유합니다. 이를 통해 동시에 실행되는 코드가 IPC의 오버헤드나 복잡성 없이 긴밀하고 편리하게 데이터를 교환할 수 있도록 허락한다. 그러나 스레드 간에 공유될 때 둘 이상의 업데이트를 위한 CPU 명령이 필요한 경우 간단한 데이터 구조도 경쟁 조건이 되기 쉽다. 두 개의 스레드가 동시에 데이터 구조를 업데이트하려고 시도하려한다면 예기치 않게 발밑에서 변경되는 것을 발견할 수 있다. 경쟁 조건으로 인해 발생하는 버그는 재현 및 분리하기가 매우 어려울 수 있다. 

이를 예방하기 위해, 스레딩 API는 동시 액세스에 맡서는 데이터 구조를 잠그는 mutex와 같은 동기화 기본 요소를 제공한다. 단일 프로세서 시스템에서, lock된 mutex 에서 동작하는 스레드는 휴면 상태이여야 하므로 컨텍스트 전환을 트리거 해야 한다. 다중 프로세서 시스템에서 스레드는 대신 spinlock에서 mutex를 폴링할 수 있다. 이 두 가지 모두 성능을 저하시키고 SMP 시스템의 프로세서가 메모리 버스를 두고 경쟁하도록 할 수 있다. 특히 잠금 단위가 너무 세밀한 경우













