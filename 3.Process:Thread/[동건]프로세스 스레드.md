### 프로세스 

운영체제를 논의할 때 모든 cpu 활동들을 어떻게 부를 것인가 의문이 있었다.

- Batch System (일괄 처리 시스템) : 일정 시간동안 수집된 변동 자료를 컴퓨터의 입력 자료로 만들었다가 필요한 시점에서 이 자료들을 일괄 입력하여 실행한 후 그 결과를 일괄 출력시켜 주는 방식 - **job**
- Time-shared Systems (시분할 시스템) : 컴퓨터에 직접 사용자 online terminal로 연결해서 사용자들이 바료 사용할 수 있는 시스템으로 바뀜 - **tasks**
- job, task 모두 포함하는게 프로세스. 비공식적으로, 프로세스란 실행 중인 프로그램. 프로세스의 현재 활동의 상태는 pc 값과 프로세서 레지스터 내용으로 나타낸다.

**프로그램(Program)은 명령어 리스트를 내용으로 가진 디스크에 저장된 파일(실행 파일이라고 불림)과 같은 수동적인 존재(passive entity)이다.**

**프로세스(Process)는 다음에 실행할 명령어를 지정하는 프로그램 카운터(PC)와 관련 자원의 집합을 가진 능동적인 존재(active entity)이다. 실행 파일이 메모리에 적재될 때 프로그램은 프로세스가 된다.**



메인 메모리 안의 프로그램 내용은 한 덩어리로 들어가 있는 것이 아니라 크게 4가지 영역으로 구현된다.

![image-20210807112721875](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210807112721875.png)

- text : 실행 코드
- data : 전역 변수
- heap : 프로그램 실행 중에 동적으로 할당되는 메모리
- stack : 함수를 호출할 때 임시 데이터 저장장소 (ex. 함수 매개변수, 복귀 주소, 지역변수....)



### 프로세스 구성

프로세스에 대한 정보는 PROCESS CONTROL BLOCK 또는 PROCESS DESCRIPTOR 라고 부르는 자료구조에 저장된다.

**PCB에  담긴 정보들**

- PID

  : 프로세스 식별번호

- 프로세스 상태

  : create, running, ready, waiting, terminated

- 프로그램 카운터

  : cpu가 다음으로 실행할 명령어를 가리키는 값

- 스케줄링 우선순위

  : 여러 개의 프로세스가 cpu에서 실행되는 순서를 결정하는 것

- 권한

  : 프로세스가 접근할 수 있는 자원을 결정하는 정보

- 프로세스의 부모와 자식 프로세스

  : 각 프로세스의 자식 프로세스와 부모 프로세스에 대한 정보

- 프로세스의 데이터와 명령어가 있는 메모리 위치를 가리키는 포인터

- 프로세스에 할당된 자원들을 가리키는 포인터

- 실행 문맥

  : 마지막으로 실행한 프로세서의 레지스터 내용



### IPC

프로세스 간 통신이란 프로세스들 사이에 서로 데이터를 주고받는 행위 또는 그에 대한 방법이나 경로를 뜻한다.

**1. shared memory**

- 2개의 process가 공유하는 메모리 영역
- p1, p2 사이에 공유하는 shared memory 있다면 shared memory 벗어나게 쓰거나, 비어 있는데 읽거나, 꽉 찼는데 계속 쓴다거나, 2개의 process 동시에 접근해 inconsistency (동기화 해야함) 일어난다면 운영체제가 관여하지 않고 shared memory 사용하는 process 가 알아서 처리한다.
- 운영체제는 shared memory 만들고 p1, p2에 붙여주는 역할만 하낟.



**2. message passing**

- 데이터 주고 받기 위해 메시지 전달

- 기능

  - send
  - receive

- 통신하려면 프로세스 (P, Q) 사이에 communication link 있어야 한다.

  



### 스레드가 필요한 이유

스레드라는 개념이 없어 프로세스만 존재했을 때 발생하는 상황이다.

메신저로 예시를 들어 생각해보면 내가 키보드로 입력한 것을 가지고 화면에 출력해야하고 동시에 상대방이 입력한 것도 출력되어야 한다.

내가 키보드로 입력을 하고 있을 때 사용자 A로부터 메세지 패킷이 네트워크로 도착했다고 가정하면, 패킷이 도착했음에도 불구하고  입력을 받기 위해 입력함수가 기다리고 있어 메시지를 받을 수 없다.

왜일까?

**프로그램은 위에서 아래로 흐르는 단 하나의 실행 path를 가지고 있기 때문이다.**

메신저는 path 하나로 소통이 안되니 이를 해결하기 위해 프로세스를 추가로 생성한 것이다.

사용자가 입력하는 것을 처리하는 실행 path를 만들고, 네트워크로부터 패킷이 도착하는 것을 처리하는 실행 path를 만들어 줘야 입력해주는 것과 받는 것을 별도로 동시에 운용할 수 있다라는 것이가장 기본적인 프로세스의 개념이다.

**여기서 문제 발생!**

![image-20210807084336346](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210807084336346.png)

위 그림처럼 프로세스는 각각 독립된 자원할당을 갖는다. 서로 공유를 하지 않는 것이다. 각각 별개의 프로그램처럼 서로에게 관련되지 않은 실행패스를 갖게 되는 것이다.

그런데 내가 키보드로부터 입력받은 거, 네트워크로부터 입력받은거 두개 다 모두 화면에 출력할 수 있어야 하기 때문에 키보드에서 입력받은 내용을 네트워크 프로세스에 보내주던, 네트워크로부터 입력받은 내용을 키워드에 보내주던, 출력만 처리하는 또 다른 제 3자의 프로세스에 둘이 보내주던 프로세스들 사이에서 통신이 발생한다.

이 통신을 IPC를 통해 해야하는 것이다.

근데 프로그램이 커지고 시간이 지날 수록 상당히 비효율적이라는 것이다.

프로세스를 하나 생성한다는 것은 PCB를 만들고, 프로세스를 실행하는 메모리 공간 또한 별도로 만들고, 프로세스들끼리의 IPC 통신, 프로세스간에 Context swithching 까지 오버헤더가 많아진다는 것이다.



### 스레드의 의의

어차피 같은 채팅이면 비슷한 개념으로 프로세스 하나에 여러 흐름을 만들고 자원을 공유하자.![image-20210807085130751](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210807085130751.png)

b그림처럼 프로세스에 흐름이 여러개인 형태이면 PCB도 하나면 되고, 메모리 공간도 하나이므로 각 흐름끼리 데이터를 주고 받을 때 커널이 굳이 중간에 껴서 IPC 통신 안해도 되는 여러가지 이점이 생긴다.



### 스레드의 역사

1965년 - 버클리 시분할 시스템에서 처음 사용되었다. 이 때는 스레드라는 이름 대신에 프로세스라고 불렀다. 이 프로세스는 공유 변수나 세마포 혹은 그와 유사한 방법들을 통해 서로 상호작용 했다.

1970년대 - 맥스 스미스가 멀틱스에 최초로 스레드를 구현 (한 개의 무거운 프로세스 안에서 멀티 스택을 이용해 백그라운드 컴파일을 돕는 기능)

스레드에 있어 가장 중요한 시작은 아마도 1965년에  나온 PL/I라는 프로그래밍 언어부터 일 것이다.

위키

1967년 MVT 에서 스레드가 TASK 라는 이름으로 처음 등장했다.

솔쳐(1966)는 빅터 A.비소츠키의 'thread' 라는 용어를 인정한다.

스레딩의 인기는 2003년 경에 증가된 CPU 주파수가 코어 수 증가로 대체되면서 여러 코어를 활용하기 위해서는 동시성이 요구된다.



### 단일 스레딩 vs 다중 스레딩

단일 스레딩은 한 번에 하나의 명령어를 처리하는 것입니다. 변수의 의미론과 프로세스 상태에 대한 공식적인 분석에서, 단일 스레딩이라는 용어는 "backtracking within a single thread"이라는 의미로 다르게 사용될 수 있다.

멀티스레딩은 주로 멀티태스킹 운영 체제에서 찾을 수 있습니다. 멀티스레딩은 하나의 프로세스 컨텍스트 내에 여러 스레드가 존재할 수 있도록 지원하는 광범위한 프로그래밍 및 실행 모델이다. 이러한 스레드는 프로세스의 리소스를 공유하지만 독립적으로 실행할 수 있습니다. 다중 처리 시스템에서 병렬 실행을 활성화하기 위해 하나의 프로세스에 멀티스레딩을 적용한다.



### 다중 스레드 모델

**user thread** : 사용자 스레드는 커널 영역의 상위에서 지원되며 일반적으로 사용자 레벨의 라이브러리를 통해 구현되며, 라이브러리는 스레드의 생성 및 스케줄링 등에 관한 관리 기능을 제공한다.
동일한 메모리 영역에서 스레드가 생성 및 관리되므로 속도가 빠른 장점이 있는 반면, 여러 개의 사용자 스레드 중 하나의 스레드가 시스템 호출 등으로 중단되면 나머지 모든 스레드 역시 중단되는 단점이 있다. 이는 커널이 프로세스 내부의 스레드를 인식하지 못하며 해당 프로세스를 대기 상태로 전환시키기 때문이다.

- posix ptrheads
- windows threads
- java threads 



**kernel threads** : 커널 스레드는 운영체제가 지원하는 스레드 기능으로 구현되며, 커널이 스레드의 생성 및 스케줄링 등을 관리한다. 스레드가 시스템 호출 등으로 중단되더라도, 커널은 프로세스 내의 다른 스레드를 중단시키지 않고 계속 실행시켜준다. 다중처리기 환경에서 커널은 여러 개의 스레드를 각각 다른 처리기에 할당할 수 있습니다. 다만, 사용자 스레드에 비해 생성 및 관리하는 것이 느립니다.

- windows
- solaris
- linux
- tru64 unix
- mac os x



**1. many to one 모델**

<img src="C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210807121343139.png" alt="image-20210807121343139" style="zoom: 80%;" />

**여러 개의 사용자 수준 스레드들이 하나의 커널 스레드(프로세스)로 매핑되는 방식**으로, 사용자 수준에서 스레드 관리가 이루어집니다. 주로 커널 스레드를 지원하지 않는 시스템에서 사용하며, 한 번에 하나의 스레드만이 커널에 접근할 수 있다는 단점이 있습니다.

하나의 스레드가 커널에 시스템 호출을 하면 나머지 스레드들은 대기해야 하기 때문에 진정한 의미의 동시성을 지원하지 못합니다. 다시 말해, 여러 개의 스레드가 동시에 시스템 호출을 사용할 수 없습니다. 또한 커널 입장에서는 프로세스 내부의 스레드들을 인식할 수 없고 하나의 프로세스로만 보이기 때문에 다중처리기 환경이라도 여러 개의 프로세서에 분산하여 수행할 수 없습니다.



**2. one to one 모델**

<img src="C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210807121638242.png" alt="image-20210807121638242" style="zoom: 80%;" />

**사용자 스레드들을 각각 하나의 커널 스레드로 매핑시키는 방식**입니다. 사용자 스레드가 생성되면 그에 따른 커널 스레드가 생성되는 것입니다. 이렇게 하면 다-대-일 방식에서 시스템 호출 시 다른 스레드들이 중단되는 문제를 해결할 수 있으며 여러 개의 스레드를 다중처리기에 분산하여 동시에 수행할 수 있는 장점이 있습니다.

그러나 커널 스레드도 한정된 자원을 사용하므로 무한정 생성할 수는 없기 때문에, 스레드를 생성할 때 그 개수를 염두에 두어야 합니다.

윈도우와 리눅스가 이 모델을 구현하고 있습니다.



**3. many to many 모델**

<img src="C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210807121723094.png" alt="image-20210807121723094" style="zoom:80%;" />

**여러 개의 사용자 스레드를 여러 개의 커널 스레드로 매핑시키는 모델**입니다. 다-대-일 방식과 일-대-일 방식의 문제점을 해결하기 위해 고안되었습니다. 커널 스레드는 생성된 사용자 스레드와 같은 수 또는 그 이하로 생성되어 스케줄링합니다. 다-대-일 방식에서 스레드가 시스템 호출시 다른 스레드가 중단되는 현상과 일-대-일 방식에서 사용할 스레드의 수에 대해 고민하지 않아도 됩니다. 커널이 사용자 스레드와 커널 스레드의 매핑을 적절하게 조절합니다.



### 멀티 스레드 vs 멀티 프로세스

- 멀티 스레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 context swithcning이 빠른 장점이 있지만, 동기화 문제와 하나의 스레드 장애로 전체 스레드가 종료 될 위험을 갖고 있다.
- 멀티 프로세스는 하나의 프로세스가 죽더라도 다른 프로세스에 영향을 주지 않아 안정성이 높지만, 멀티 스레드보다 많은 메모리공간과 CPU 시간을 차지하는 단점이 있다.
- 두 방법은 동시에 여러 작업을 수행하는 점에서 동일하지만, 각각의 장단이 있으므로 적용하는 시스템에 따라 적합한 동작 방식을 선택하고 적용해야 한다.



### 멀티 프로세스

- 두개 이상 다수의 프로세서(`CPU`)가 협력적으로 하나 이상의 작업(`Task`)을 동시에 처리하는 것이다. (병렬처리)
- 각 프로세스 간 메모리 구분이 필요하거나 독립된 주소 공간을 가져야 할 경우 사용한다.



**장점**

- 독립된 구조로 안전성이 높은 장점이 있다.
- 프로세스 중 하나에 문제가 생겨도 다른 프로세스에 영향을 주지 않아, 작업속도가 느려지는 손해정도는 생기지만 정지되거나 하는 문제는 발생하지 않는다.
- 여러개의 프로세스가 처리되어야 할 때 동일한 데이터를 사용하고, 이러한 데이터를 하나의 디스크에 두고 모든 프로세서(`CPU`)가 이를 공유하면 비용적으로 저렴하다.

**단점**

- 독립된 메모리 영역이기 때문에 작업량이 많을수록( Context Switching이 자주 일어나서 주소 공간의 공유가 잦을 경우) 오버헤드가 발생하여 성능저하가 발생 할 수 있다.
- Context Switching 과정에서 캐시 메모리 초기화 등 무거운 작업이 진행되고 시간이 소모되는 등 오버헤드가 발생한다.



### 멀티 스레드

<img src="https://2.bp.blogspot.com/-3AB4sE53Dfw/VMVNdWa_V0I/AAAAAAAAACo/UAGFO7f6_UA/s1600/euva3a00.p54z.gif" alt="img" style="zoom: 33%;" />

- 하나의 프로세스에 여러 스레드로 자원을 공유하며 작업을 나누어 수행하는 것이다.

**장점**

- 시스템 자원소모 감소 (자원의 효율성 증대)
  - 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어 자원을 효율적으로 관리할 수 있다.
- 시스템 처리율 향상 (처리비용 감소)
  - 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어든다.
  - 스레드 사이 작업량이 작아 `Context Switching`이 빠르다. (캐시 메모리를 비울 필요가 없다.)
- 간단한 통신 방법으로 프로그램 응답시간 단축
  - 스레드는 프로세스 내 스택영역을 제외한 메모리 영역을 공유하기에 통신 비용이 적다.
  - 힙 영역을 공유하므로 데이터를 주고 받을 수 있다.

**단점**

- 자원을 공유하기에 동기화 문제가 발생할 수 있다. (병목현상, 데드락 등)
- 주의 깊은 설계가 필요하고 디버깅이 어렵다. (불필요 부분까지 동기화하면, 대기시간으로 인해 성능저하 발생)
- 하나의 스레드에 문제가 생기면 전체 프로세스가 영향을 받는다.
- 단일 프로세스 시스템의 경우 효과를 기대하기 어렵다.



요즘 멀티프로세서 구조( 프로세스 여러개, 한 프로세스 core 여러개) 가진 cpu 여러개인 컴퓨터가 늘어나고 있다.

cpu가 여러개 있는 컴퓨터 잘 활용하려면 스레드가 많은 응용이 좋다. 

core가 8개 -> 8개 스레드 잇으면 각각 core가 병렬적으로 수행할 수 있다.



**완전 별개의 기능을 여러가지 가지고 있는 프로그램이라면 독립적인 프로세스를 구성하는 것이 좋고 서로 관련된 기능은 멀티 스레드로 구현하는 것이 좋을 것 같다.**



**멀티 스레드의 효율성과 안정성 문제**

여러 개의 스레드가 동일한 데이터 공간을 공유하면서 이들을 수정한다는 점에 필연적으로 생기는 문제이다.

멀티 프로세스의 방식의 프로그램에서 하나의 프로세스가 자신의 데이터 공간을 망가뜨린다면 그것은 해당 프로세스의 중단을 낳게 될 것이다. 하지만 멀티 스레드 방식의 프로그램에서는 하나의 스레드가 자신이 사용하던 데이터 공간을 망가뜨린다면 그 결과는 하나의 데이터 공간을 공유하는 모든 스레드를 작동불능 상태로 만들어 버릴 것이다.







